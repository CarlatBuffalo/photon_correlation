\documentclass{article}

\usepackage[squaren]{SIunits}
\usepackage{amsmath,amsfonts}
\usepackage{appendix}

\newcommand{\cps}{cps}
\newcommand{\braces}[1]{\ensuremath{\left\lbrace #1 \right\rbrace}}
\newcommand{\angles}[1]{\ensuremath{\left\langle #1 \right\rangle}}
\newcommand{\stdin}{\texttt{stdin}}
\newcommand{\stdout}{\texttt{stdout}}
\newcommand{\stderr}{\texttt{stderr}}
\newcommand{\picoquant}{\texttt{picoquant}}
\newcommand{\intensity}{\texttt{intensity}}
\newcommand{\correlate}{\texttt{correlate}}
\newcommand{\histogram}{\texttt{histogram}}
\newcommand{\gn}[1]{\ensuremath{g^{(#1)}}}
\newcommand{\integers}{\ensuremath{\mathbb{Z}}}
\newcommand{\wholes}{\ensuremath{\mathbb{N}}}
\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\renewcommand{\vec}{\mathbf}
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\eV}{\textnormal{eV}}

\title{Picoquant: Tools for reading and analyzing Picoquant data files}
\author{Thomas Bischof \\ \texttt{tbischof@mit.edu}}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
 
\section{Introduction}
\subsection{The layout of this document}
This document is laid out in roughly three parts:
\begin{enumerate}
\item Overview of terminology and methods
\item Documentation for each program
\item Applications of the software to real problems
\end{enumerate}
In the chapters devoted to the various programs, the documentation is divided further:
\begin{enumerate}
\item Command-line syntax
\item Theoretical overview of the purpose of the program
\item Details of the implementation
\end{enumerate}

\subsection{A (very) brief overview of photon-arrival timing}
In single-molecule spectroscopy, single-photon detectors are often used to perform time-resolved experiments. Detectors such as silicon-based avalanche photodiodes (APDs) can be used to detect the arrival time a photon with about 500\pico\second{} resolution, and can detect up to $10^{7}$ photons per second before saturation, abbreviated as 10\mega\cps{} hereafter (counts per second). Hardware capable of resolving these arrival times is of great use for revealing time-dependent structure to the photon stream, such as intensity fluctuations and bunching, so various hardware designs have been developed to permit such measurements.

One line of instruments is the timing hardware produced by Picoquant GmBH, such as the Timeharp, Picoharp, and Hydraharp. These modules are capable of detecting pulse arrivals on multiple input channels with a resolution of as little as 1\pico\second, and operate in a few distinct modes:
\begin{enumerate}
\item Interactive (histogram): one input channel is designated as a sync source, representing a clock-starting signal. On the other channels, pulse arrival times are recorded relative to this clock source, and the times binned into a histogram. 
\item Time-tagged time-resolved (TTTR): 
	\begin{enumerate}
	\item T2: all channels are treated equally, and all pulse arrival times relative to the start of the experiment are recorded. 
	\item T3: this is similar to histogram mode, but instead of binning the arrival times, the sync event number and relative arrival time are both recorded.
	\end{enumerate}
\end{enumerate}

In all cases, the times are discrete and represent some number of cycles of a clock, so all times must be treated as integers representing some number of picoseconds. This has important effects on the definition of time bins for histograms, and where appropriate some time will be devoted to discussing these factors. 

Considering these distinct modes, it is important to spend some time discussing their uses, and how their data should be handled.

\subsection{Data collection modes}
\subsubsection{Interactive (histogram)}
A common experiment for studying fluorophores is to measure the time dependence of their response to an excitation. For example, a pulsed laser can be used to excite a sample, and the resulting fluorescence detected by an APD. Because single-photon detectors are limited to detection of a single photon at once, to reconstruct the decay curve it is necessary to average the result over many pulses of the laser, binning the arrival times of the emitted photons relative to that of the laser. If measuring this time-averaged behavior is sufficient, then the interactive histogram mode is used to perform all of this collection and binning on the hardware without any post-processing. 

Consequently, interactive data consists of $N$ unique arrival time bins with boundaries $(t_{j}, t_{j+1})$ and the number of counts $n_{j}$ associated with that bin, so the data can be represented by the set:
\begin{equation}
\braces{((t_{j}, t_{j+1}), n_{j})}
\end{equation}
The exact choice of where the boundaries lie has some effect on the resulting histogram, but this performed in the hardware and presumably represents $t\in[t_{j}, t_{j+1})$. This choice is not detailed in the manuals for the hardware, but it is of little practical importance; typical detectors have two orders of magnitude more timing jitter than the timing hardware, so the exact definition of the histogram bin has a negligible effect.

\subsubsection{T2}
In T2 mode, all input channels are connected to photon detectors. At the start of the experiment, an internal clock is reset and started, providing a master timing reference. As a pulse arrives, the machine emits data encoding the channel and time of arrival, so the data follow the form:
\begin{equation}
\braces{(c_{j}, t_{j})}
\end{equation}
for a channel $c_{j}$ and arrival time $t_{j}$ of the $j$th photon. 
%Typically, these data are used to examine time-dependent behavior, such as intensity fluctuations, particularly when the excitation source is continuous-wave. These data are also useful for calculation of correlation functions such as:
%\begin{equation}
%\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
%	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
%	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
%\end{equation}
%The details of this calculation will laid out later in section~\ref{sec:correlate}, but one use of the $g^{(2)}(t)$ is to determine the number of emitters present in a signal. For example, a single emitter emitting one photon at any time will exhibit so-called antibunching behavior, where $g^{(2)}(t)\rightarrow 0$ for $t\approx 0$, indicating a diminished probability of seeing two successive photon emissions ($g^{(n)}(\braces{t_{j}})=1$ indicates no correlation). Correlations of higher order ($n\ge 3$) have their own uses, but quickly become computationally expensive for reasons which will become clear later.

\subsubsection{T3}
T3 mode is closest in character to the interactive mode, except that, instead of binning the photon arrival times on the hardware, the arrivals are recorded directly for later examination, as in T2 mode. This gives a data set of the form:
\begin{equation}
\braces{(c_{j}, p_{j}, t_{j})}
\end{equation}
for channel $c_{j}$, sync pulse number $p_{j}$, and relative arrival time $t_{j}$. Indeed, by defining temporal bins and histogramming the $t_{j}$, the result from the interactive mode can be reproduced exactly.

\paragraph{Mapping T3 onto T2 data}
For signals produced by regular excitation it is possible to convert T3 data to T2 data. For example, consider a sample excited by a laser with repetition rate $f$. The pulse number therefore defines a time $1/f$, and $t_{j}$ acts as a correction to this time:
\begin{equation}
\left(c_{j}, p_{j}, t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}}{f} + t_{j}\right)
\end{equation}
Of course, this conversion is not necessarily perfect. For example, sync pulses may be missed or overcounted, introducing a cumulative error $\delta p_{j}$, the frequency of the sync pulse might deviate with some jitter $\delta f$, or the timing of the arrival might have some jitter $\delta t_{j}$, such that the true expression is:
\begin{equation}
\left(c_{j}, p_{j}+\delta p_{j}, t_{j} + \delta p_{j} \right)
      \rightarrow \left(c_{j}, \frac{p_{j}+\delta p_{j}}{f+\delta f} + t_{j}+\delta t_{j}\right)
\end{equation}
For a well-designed system these errors should not be very large, but if an application requires precision approaching that of the timing hardware they can be quite important. 

% However, this mode also allows for studying time dependence and correlation in the data, as with T2 mode. In principle, any data collected in T3 mode can be transformed into T2 mode data if the sync source is regular, as the pulse number will represent some amount of time in the experiment, but there are subtle hardware and numerical issues (discussed later) which limit the practicality of this transformation.
%
%Uses of this mode include the study of the time-dependent fluoresence lifetime of single molecules, which can switch between distinct states under various conditions. Correlation methods can also reveal important behavior, but again this will be discussed later.

\subsection{Correlation techniques}
A number of techniques involving the correlation of one or more signals exist, and their use in fluorescence microscopy requires that we be able to calculate correlation functions of the following form:
\begin{equation}
\gn{n}(\tau_{1}, \ldots \tau_{n-1}) \approx \frac
	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
\end{equation}
The details of calculating this function will be laid out in section~\ref{sec:math_background}. For now, note that the problem can be divided into three distinct parts:
\begin{enumerate}
\item Calculation of \angles{I_{j}(t)}
\item Finding correlation events
\item Histogramming correlation events
\end{enumerate}

\subsection{General design principles}
Analysis of these timing data can be roughly described as follows:
\begin{enumerate}
\item Produce a stream of photon events
\item Condition the stream by correlation, removal of extraneous information, homogenization of the detection channels, etc.
\item Collect the result to form some histogram of events.
\end{enumerate}
As such, these three phases are handled by distinct programs, which act as filters of a data stream by reading in values and outputting the appropriate new values. These streams are ultimately streams of binary data, but for any program the stream may be defined by the standard data streams (\stdin, \stdout) or by some file containing the data. 

For time-tagged modes, times are represented as integer multiples of 1\pico\second, although only the initial data streamer is actually aware of units; the conditioning and collection routines operate on time as an integer, without regard for its units.

All programs are designed to operate on a data stream until that stream terminates, so any division of a data stream should be handled by a separate program and the result fed into a distinct instance of the handler. 

The main processing software (\picoquant, \intensity, \correlate, \histogram) is written in the C programming language, using the C99 standard. Where necessary, the definitions of data types have been defined to be of fixed width, but otherwise the definitions are those minimal for handling reasonable values. For example, in T2 mode time is defined as a signed 64-bit integer, representing $\approx 10^{19}\pico\second$, or $10^{7}\second$, or $106$ days. Pulses are counted as signed 64-bit integers, limiting their total to several thousand years of 10\mega\hertz{} pulsed laser excitation. With luck, your experiments will not exceed these values. 

In addition to the C code, several analysis scripts written in Python have been provided in \text{scripts/}. These include routines to read in the outputs of most of the processing software, generate correlation functions, plot lifetime data, and so on. 

All programs will display command-line syntax when the flag \texttt{-h} or \texttt{--help} is given. They have been tested most thoroughly on 32-bit and 64-bit Linux systems with the GNU C compiler, but in principle should work on any system with a C99-compliant compiler. Non-standard libraries are not used, to limit portability issues. A Makefile is present in the \texttt{src} directory which should be sufficient for compiling the software, although it will require some modification for different compiler configurations.

\section{The mathematics of calculating \gn{n}}
\label{sec:math_background}
This section will detail the mathematics of calculating correlation functions \gn{n}. If you are familiar with the results, you can safely skip this section, but do note that the correlation of photon events is in subtle ways distinct from a standard signal correlation.

If you are not familiar with notation such as
\begin{align}
Z_{n} &= \abs{\braces{a|a\in\integers;~ a\in\integers/n}} \\
F&:\wholes\times\integers\rightarrow\reals \\
&\sum_{z\in\integers_{n}}{z^{2}}
\end{align}
you should read appendix~\ref{sec:notation} before reading the remainder of this section.

\subsection{Definition of the correlation function}
A signal $I(t)$ is a non-negative, real-valued function of whole time:
\begin{equation}
I:\wholes\rightarrow\reals^{*}
\end{equation}
In practice such a function may represent a physical quantity such as voltage, and we will develop our understanding of photon correlations by developing first an understanding of how to correlate this sort of function. 

The simplest non-trivial correlation of a function is the autocorrelation, which measures the average probability that the value of the function for a time $t+\tau$ will be greater than, less than, or equal to its value at $t$. This can be calculated as:
\begin{equation}
\label{eq:autocorrelation}
\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
                    {\angles{I(t)}\angles{I(t+\tau)}}
\end{equation}
Here, $\gn{2}>1$ indicates supercorrelation, that the function is more likely than not to increase in value after a time delay $\tau$. If $\gn{2}<1$, the function is more likely than not to decrease in value after a time delay $\tau$. And in the middle, if $\gn{2}=1$, the function has equal probability to increase, decrease, or remain constant. The meaning of the exact magnitude of $\gn{2}(\tau)$ can be discussed in the context of a particular function, but these general principles should always apply.

In many cases, an autocorrelation is an oversimplification of a signal, and it is useful to be able to compare the cross-correlations of two or more channels instead. For example, if our function $I$ is endowed with a second dimension indicating the identity of a detection channel from the set $C$ of detection channels, it takes the form
\begin{equation}
I:C\times\wholes\rightarrow\reals^{*}
\end{equation}
where $\times$ is the Cartesian product of elements from $C$ and $\integers^{*}$. For example, if $C=\braces{0, 1}$, elements of $C\times\wholes$ take the form of 2-tuples such as (0, 10), (1, 17), (0, 0), and so on. Under this notation, $I$ is now a function of two variables and follows the form $I(c, t)$. For clarity of future notation, we will include the channel variable as a subscript:
\begin{equation}
I(c,t)\equiv I_{c}(t)
\end{equation}
Given this, we can separate the signal $I$ into a sum of signals over all channels:
\begin{equation}
I(t) \equiv \sum_{c\in C}{I_{c}(t)}
\end{equation}
Under the definition of an autocorrelation as in equation~\ref{eq:autocorrelation}, we can substitute this new value and expand the result to obtain:
\begin{equation}
\gn{2}(\tau)=\sum_{(c_{0},c_{1})\in C^{2}}{\frac{\angles{I_{c_{0}}(t)I_{c_{1}}(t+\tau)}}
                                                {\angles{I_{c_{0}(t)}}\angles{I_{c_{1}}(t+\tau)}}}
\end{equation}
where $(c_{0},c_{1})\in C^{2}$ indicates 2-tuple elements of the set $C\times C$. We see that, if $C$ contains a single element (we have only one detection channel), the function returns to the form shown in equation~\ref{eq:autocorrelation}. But if we have a set $C$ with more than one element, there are more than one term in the summation, which each take the form
\begin{equation}
\gn{2}_{(c_{0},c_{1})}(\tau)=\frac{\angles{I_{c_{0}}(t)I_{c_{1}}(t+\tau)}}
                                                {\angles{I_{c_{0}(t)}}\angles{I_{c_{1}}(t+\tau)}}
\end{equation}
We will focus most of our attention on this part of the function, because the summation over all channel combinations ($\vec{c}\equiv (c_{0}, c_{1},\ldots)\in C^{n}$), is implied when specifying \gn{2}. 

Now that we have generalized this definition to an arbitrary number of channels, we can also generalize the correlation to an arbitrary order $n$:
\begin{equation}
\label{eq:gn}
\gn{n}(\tau_{1},\ldots\tau_{n-1}) = \sum_{\vec{c}\in C^{n}}{
     \frac{\angles{I_{c_{0}}(t)\prod_{j=1}^{n-1}{I_{c_{j}}(t+\tau_{j})}}}
          {\angles{I_{c_{0}}(t)}\prod_{j=1}^{n-1}{\angles{I_{c_{j}}(t+\tau_{j})}}}}
\end{equation}

\subsubsection{Examples of correlations of functions}
To become more familiar with the behavior of these correlation functions, we should evaluate them for a few familiar functions. For example, for $I(t)=1+\sin{(t)}$:
\begin{align}
\gn{2}(\tau) &= \frac{\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\left(1+\sin{(t+\tau)}\right)\,dt}}
                     {\left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\,dt}\right)
                      \left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t+\tau)}\right)\,dt}\right)} \\
             &= 1 + \frac{1}{2}\cos{(\tau)}
\end{align}
For, this result says that, given that our function at some value at time $t$, after a small time delay $\tau\approx 0$ the value is likely to have increased ($\gn{2}=1.5$). If you were expecting $\gn{2}(0)$ to be 1, note that the correlation function is not strictly an increase or decrease of the value of the function, but instead more akin to a weighted average of that character. Thus, while the function has intervals of equal size over which it increases ($t\pmod{2\pi} \in (0,\frac{\pi}{2})\cup(\frac{3\pi}{2})$) or decreases ($t\pmod{2\pi} \in (\frac{\pi}{2},\frac{3\pi}{2})$), the time it spends with value greater than average ($t\pmod{2\pi}\in(0,\pi)$) weighs more heavily. 

Additionally, at $\tau=2\pi$, the value of the function is exactly what it was at $\tau=0$, so $\gn{2}(2\pi)=1$.

Moving on, consider a signal composed of two Gaussian functions:
\begin{align}
I_{0}(t) &= \frac{1}{\sigma_{0}\sqrt{2\pi}}\exp{\left(-(t-\mu_{0})^{2}/(2\sigma_{0}^{2})\right)} \\
I_{1}(t) &= \frac{1}{\sigma_{1}\sqrt{2\pi}}\exp{\left(-(t-\mu_{1})^{2}/(2\sigma_{1}^{2})\right)} \\
I(t) &= I_{0}(t)+I_{1}(t)
\end{align}
We can calculate the full autocorrelation as the sum of the cross-correlations:
\begin{align}
\gn{2}(\tau) &= \gn{2}_{(0,0)}(\tau)+\gn{2}_{(0,1)}(\tau)+\gn{2}_{(1,0)}(\tau)+\gn{2}_{(1,1)}(\tau) \\
             &= 
\end{align}

% A correlation of such a signal quantifies the randomness of its behavior over time: a signal with strong time correlation has well-defined behavior at a time $I(t+\tau)$ given a value at $I(t)$, and weaker correlation indicates that the value is less well-defined, approaching complete randomness. The correlation of a signal with itself (its autocorrelation) can be defined as:
%\begin{equation}
%\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
%                    {\angles{I(t)}\angles{I(t+\tau)}}
%\end{equation}
%where the angled brackets indicate an average over $t$. For this function, a value $\gn{2}(\tau)=1$ indicates non-correlation: at a time delay $\tau$, the value $I(t+\tau)$ is on average the same as $I(t)$. For $\gn{2}(\tau)>1$, $I(t+\tau)$ is greater than $I(t)$, and for $\gn{2}(\tau)<1$, $I(t+\tau)$ is less than $I(t)$. In terms of photon correlation methods, $\gn{2}(\tau)>1$ is called super-bunching (a photon arrival is likely to be followed by another), while $\gn{2}(\tau)<1$ is called anti-bunching (a photon arrival is likely to be followed by a lack of photons).
%
%For example, consider the autocorrelation of a sinusoid:
%\begin{align}
%\gn{2}(\tau) &= \frac{\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\left(1+\sin{(t+\tau)}\right)\,dt}}
%                     {\left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\,dt}\right)
%                      \left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t+\tau)}\right)\,dt}\right)} \\
%             &= 1 + \frac{1}{2}\cos{(\tau)}
%\end{align}
%it is evident that there is some structure to the autocorrelation, such that there is some probability of the signal being stronger or weaker at relative time delays $\tau$. 
%
%As an example which is more relevant to photon-correlation, consider a pulse train represented by
%\begin{equation}
%\label{eq:delta_train}
%I(t) = \sum_{n\in\integers}{\delta(t-n)}
%\end{equation}
%where $\delta$ here represents the mathematical delta function
%\begin{equation}
%\delta(t) = \left\lbrace \begin{split}
%                          1;~t=0 \\
%                          0;~t\not=0
%                         \end{split}
%            \right.
%\end{equation}
%This signal represents is a regularly-spaced pulse train where a single pulse arrives every unit of time, and as such its autocorrelation is:
%\begin{equation}
%\gn{2}(\tau) = \sum_{n\in\integers}{\delta(\tau-n)}
%\end{equation}
%
%
%\subsection{Extending the correlation arbitrary numbers of signals}
%While the autocorrelation of a signal is often a meaningful quantity to calculate, cross-correlations are more general and have many more applications. For example, the cross-correlation of a laser pulse train and the response of a light-emitting sample can be used to measure the lifetime of the emissive state, and is the implicit measurement of the interactive mode. 
%
%Generalization of the correlation is fairly simple: the numerator holds an average over a product of some number of signals with time delays relative to a reference channel, normalized by the average intensity at each channel. For two channels, this can be expressed as:
%\begin{equation}
%\label{eq:g2}
%\gn{2}(\tau) = \frac{\angles{I_{0}(t)I_{1}(t+\tau)}}
%                    {\angles{I_{0}(t)}\angles{I_{1}(t+\tau)}}
%\end{equation}
%Generalization to higher dimensions is relatively straightforward:
%\begin{equation}
%\label{eq:gn}
%\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
%	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
%	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
%\end{equation}
%where the $\prod$ notation indicates a product of elements, akin to the $\sum$ notation for summation.

%\subsubsection{Mapping T3 correlations onto T2-like correlations}
%One benefit of generalizing the correlation to higher dimensions is that it provides a simple way to treat correlations of T3 data as higher-dimensional T2 data. For example, if we apply the map
%\begin{equation}
%\left(c_{j}, p_{j}, t_{j}\right) \rightarrow \left(\left(c_{j}, p_{j}\right), \left(c_{j}, t_{j}\right)\right)
%\end{equation}
%it is evident that we can treat the single T3 entry as containing two dimensions of time to analyze independently. Therefore, any calculation of a correlation of T3 data can be expressed as
%\begin{equation}
%\gn{n}(\rho_{1}, \tau_{1}, \ldots \rho_{n-1}, \tau_{n-1}) = \frac
%	{\angles{I_{0}(p, t)\prod_{j=1}^{n-1}{I_{j}(p+\rho_{j},t)I_{j}(p,t+\tau_{j})}}}
%	{\angles{I_{0}(p, t)}^{2}\prod_{j=1}^{n-1}{\angles{I_{j}(p+\rho_{j},t)}
%	                                       \angles{I_{j}(p,t+\tau_{j})}}}
%\end{equation}
%For the rest of this paper, T3 data will be treated as higher-dimensional T2 data.
%
%\subsection{The true meaning of $I(t)$}
%For many measurements, the signals $I_{j}(t)$ are real-valued and defined by averaging some signal for a time interval $\Delta t$, such that the value $I_{j}(t)$ really is
%\begin{equation}
%I_{j}(t) = \left.\angles{\iota_{j}(t')}\right|_{t'\in[t,t+\Delta t)} = \frac{1}{\Delta t}\int_{t}^{t+\Delta t}{\iota_{j}(t'),dt'}
%\end{equation}
%for a the true function $\iota(t)$. As such, the $I(t)$ over time can be represented meaningfully as a vector representing the value of the function for evenly-spaced values of $t$, and the correlations can be determined as inner products of displacements of that vector. More concretely, consider a signal $\vec{I}\in\reals^{N}$ representing $N$ samples of $I(t)$ at $t=0, \Delta t, \ldots$, with elements indexed as $\vec{I}(0), \vec{I}(1),\ldots$. To calculate $\gn{2}(\tau)$ for $\tau\in\integers^{*}$:
%\begin{equation}
%\gn{2}(\tau) = \frac{\sum_{j=0}^{N-\tau}{\vec{I}(j)\vec{I}(j+\tau)}}
%                    {\sum_{j=0}^{N-\tau}{\vec{I}(j)}\sum_{j=0}^{N-\tau}{\vec{I}(j+\tau)}}
%\end{equation}
%Note that, for $\tau\rightarrow N$, the number of elements in the sum approaches 0. This represents the undersampled region of the correlation, and as such it is necessary to define the correlation window as significantly smaller than the sampled window in order to obtain a meaningful estimate of \gn{n}.
%
%This definition of a signal is useful for many measurements of some gross quantity which can be said to sample a non-trivial range of values in \reals{} or \integers. However, photon-counting produces a signal which is fundamentally binary (in $\integers_{2}$), indicating that either a photon has arrived, or none has. In principle it is possible to bin these photon arrivals to count the number of arrivals in some time interval and recover the vector-like signal discussed above, but such steps introduce a range of subtle artifacts related to the precise origin of time and definition of bin resolution. These problems are largely avoidable if we instead develop a definition of \gn{n} which involves counting these events directly.
%
%Do note, however, that the ``true'' photon arrival time discussed from here on is itself a binary form of this vectorial definition, because real instruments will have some finite timing resolution. In this sense, the idea of a discrete arrival time is just a simplification of the true signal, where each sampling represents the state of a photon arriving or not arriving during that interval. Many more samples will find no photon than one, so those are simply not reported. Additionally, this means that the reported photon arrival time carries some time units defined by the resolution of the measurement, so we can declare any arrival time $t$ to be a multiple of these time steps, or $t\in\wholes$, where \wholes{} is the set of all whole numbers (the positive integers and zero).  
%
%\subsection{Calculating \gn{n} by counting photons}
%As in equation~\ref{eq:delta_train}, it is possible to define the signal representing arrivals of photons as a sum over a set of $\delta$-functions. Consider the set $T\subset\wholes$ of photon arrival times. The signal can be defined as
%\begin{equation}
%I(t) = \sum_{t'\in T}{\delta(t-t')}
%\end{equation}
%This notation is cumbersome, so from here we will refer to a photon arrival time as $t'$ alone, but the $\delta$ notation could be substituted as desired. This change makes the summation notation difficult to parse, so we instead switch to a set notation:
%\begin{equation}
%I(t) = \abs{\braces{\left. t'\right|t'\in T;~t-t'=0}}
%\end{equation}
%In long form, this definition counts the number of photon arrival times $t'$ which are equal to the requested time $t$. This is computationally inefficient but conceptually simple, so we will define all important quantities in this fashion before discussing how to compute the result efficiently.
%
%Extending this notation to \gn{2} for a single signal:
%\begin{equation}
%\gn{2}(\tau) = \frac{\abs{\braces{(t_{j}, t_{k})\left|
%                          \begin{split} 
%                            t_{j}, t_{k}\in T; \\
%                            t_{j}-t_{k}=\tau
%                          \end{split}\right.
%                    }}}
%                    {\abs{\braces{T}}^{2}/\left(max(T)-min(T)\right)^{2}}
%\end{equation}
%where $min$ and $max$ are the functions which return the minimum and maximum values of a set, respectively. Even this definition is not quite sufficient: the measurement carries its own unit of time $\epsilon$, which means that any time $t$ specified is really a range $[t,t+\epsilon)$, so with appropriate normalization the result becomes:
%\begin{equation}
%\gn{2}(\tau) = \frac{\abs{\braces{(t_{j}, t_{k})\left|
%                          \begin{split} 
%                            t_{j}, t_{k}\in T \\
%                            t_{j}-t_{k}=\tau
%                          \end{split}\right.
%                    }}}
%                    {\epsilon^{2}\abs{\braces{T}}^{2}/\left(max(T)-t\right)^{2}}
%\end{equation}
%This result is identical to the normalization of histogrammed values, which will be discussed later.
%
%Extending this result to a number of signals, we obtain
%\begin{equation}
%\label{eq:gn_set}
%\gn{n}(\tau_{1}, \ldots) = \frac{\abs{\braces{(t_{0}, t_{1}, \ldots)\left|
%                                      \begin{split}
%                                      t_{0}\in T_{0}; t_{1}\in T_{1};\ldots \\
%                                      t_{1}-t_{0} = \tau_{1}; \ldots
%                                      \end{split}\right.}}}
%                                {\prod_{j=0}^{n-1}{\epsilon_{j}\frac{\abs{T_{j}}}{max(T_{j})-min(T_{j})}}}
%\end{equation}
%Typically, the signals being correlated will come from the same device, such that all $\epsilon_{j}$ are equal, leading to the final formula:
%\begin{equation}
%\label{eq:gn_set}
%\gn{n}(\tau_{1}, \ldots) = \frac{\abs{\braces{(t_{0}, t_{1}, \ldots)\left|
%                                      \begin{split}
%                                      t_{0}\in T_{0}; t_{1}\in T_{1};\ldots \\
%                                      t_{1}-t_{0} = \tau_{1}; \ldots
%                                      \end{split}\right.}}}
%                                {\prod_{j=0}^{n-1}{\epsilon\frac{\abs{T_{j}}}{max(T_{j})-min(T_{j})}}}
%\end{equation}
%
%\subsection{Subdividing the problem of calculating \gn{n}}
%The expression in equation~\ref{eq:gn_set} is somewhat intimidating, but we can divide its 

\section{Picoquant}
\subsection{Purpose}
This program decodes binary data from the Picoquant hardware. Currently, \picoquant{} supports most modes and versions of the Timeharp (v2.0, v3.0, v5.0, v6.0), Picoharp (v2.0), and Hydraharp (v1.0). The board and mode are detected automatically, and if the mode is not supported an error message will explain the details.

\subsection{Command-line syntax}

\begin{verbatim}
Usage: picoquant [-r] [-v] [-i file_in] [-o file_out]
                 [-p print_every] [-n number] [-b] [-z] [-t]

        -i, --file-in: Input file. By default, this is stdin.
       -o, --file-out: Output file. By default, this is stdout.
         -n, --number: Number of entries to process (most 
                       pertinent for tttr modes). By default, 
                       processes all records.
    -p, --print-every: Print a status message after processing 
                       a specified number of entries. By default,
                       no status message is printed.
        -v, --verbose: Print debug-level information.
    -r, --header-only: Print header information, but no entries. 
                       Useful for debugging and checking file 
                       integrity.
     -b, --binary-out: Output a binary stream instead of ascii. 
                       Refer to the documentation for each mode 
                       for the details of each stream type. 
                       Generally, this will be identical to the
                       ascii mode in typing.
-z, --resolution-only: Print the time resolution of the 
                       measurement in picoseconds, then exit.
          -t, --to-t2: Convert a t3 file to a t2 file. This
                       assumes the sync channel is regular and
                       consistent over the whole run.
           -h, --help: Print this message.

        The file type and version will be 
        detected automatically from the file header.
\end{verbatim}

\subsubsection{Input}
The input is either binary stream of data from the timing hardware, or the name of a file containing that data. The details of each format are too varied and verbose to be summarized here, but are laid out in detail in section~\ref{sec:formats}.

\subsubsection{Output}
\label{sec:picoquant_output}
The output will either be written to \stdout{} or the file specified. By default, the stream will be represented as ascii text, but use of the \texttt{--binary-out} flag will skip the formatted print in favor of a raw binary stream. 

All records are processed in the order they are found in the data stream. This is typically time-ordered.

\paragraph{Interactive}
Each record is of the form:
\begin{verbatim}
struct {
    unsigned int channel;
    double left_edge;
    unsigned int counts;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, left edge of time bin, counts \n
\end{verbatim}

\paragraph{T2}
Each record is of the form:
\begin{verbatim}
struct {
    unsigned int channel;
    long long int time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, time \n
\end{verbatim}

\paragraph{T3}
Each record is of the form:
\begin{verbatim}
struct {
	unsigned int channel;
	long long int pulse_number;
	int time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, pulse number, time \n
\end{verbatim}
	
\subsection{Examples of usage}
\subsubsection{Reading header information}
\begin{verbatim}
> picoquant --file-in data.phd --header-only
Ident = PicoHarp 300
FormatVersion = 2.0
CreatorName = PicoHarp Software
CreatorVersion = 2.3.0.0
FileTime = 14/05/11 17:55:48
Comment = Untitled
NumberOfCurves = 8
   ....
\end{verbatim}

Reading these values is often a good way to check the integrity of a file, and to make sure that the correct settings are used in later processing. The keywords used here are consistent with those used in the documentation for the file type as provided by Picoquant, so common values like measurement resolution may not be identical across versions and boards. 

\subsection{Obtaining the resolution of a measurement}
Resolution values must be multiples of 1\pico\second{} for most of the devices, but for the Timeharp they are integer divisions of 1\nano\second, leading to non-integer multiples of 1\pico\second. As such, all resolution values are presented as floats, even those which could be written as integers.
\begin{verbatim}
> picoquant --file-in data.phd --resolution-only
0,1.280000e+02
1,1.280000e+02
2,1.280000e+02
3,1.280000e+02
4,1.280000e+02
5,5.120000e+02
6,1.280000e+02
\end{verbatim}
Interactive mode allows for a large number of curves, so the resolution report gives the resolution for each curve, by index.
\begin{verbatim}
> picoquant --file-in data.pt2 --resolution-only
1.280000e+02
\end{verbatim}

\subsection{Reading interactive data}
\begin{verbatim}
> picoquant --file-in data.phd
0,0.000,0
0,0.128,0
0,0.256,0
0,0.384,0
0,0.512,0
0,0.640,0
0,0.768,0
0,0.896,0
0,1.024,0
0,1.152,0
...
\end{verbatim}

\subsection{Reading t2/t3 data}
\begin{verbatim}
> picoquant --file-in data.pt2
0,7128264
0,20957636
0,33684532
0,36576452
0,42146280
0,42251400
0,65787700
0,75149552
0,86537580
0,109288316
> picoquant --file-in data.pt3
1,103,47360
1,109,47616
1,115,85760
1,115,248832
1,213,55552
1,245,244992
1,254,49920
1,267,69888
1,268,122368
1,274,58624
\end{verbatim}

\subsection{Translating t3 data to t2 data}
\begin{verbatim}
> picoquant --file-in data.pt3 --to-t2
1,41248184
1,43648488
1,46086680
1,46249752
1,85257256
1,98246952
1,101651952
1,106872024
1,107324512
1,109660816
\end{verbatim}

\subsection{Mode- and hardware-specific information}
\label{sec:formats}

While there are many differences between the formats of the files generated by the different boards and modes, they all follow a common structure:
\begin{itemize}
\item a general header identifying the board type and software version
\item a board-specific header, identifying hardware and software configuration
\item a mode-specific header
\item data
\end{itemize}

As such, the process of streaming data can be broken down into the following steps:
\begin{enumerate}
\item Identify the board type (\texttt{picoquant.c})
\item Identify the software version used to generate the file (\texttt{hydraharp.c}, \texttt{picoharp.c}, \texttt{timeharp.c}).
\item Determine the collection mode used (\texttt{hydraharp/hh\_*.c}, $\ldots$).
\item  \begin{enumerate}
  \item If the run is specified as resolution-only or header-only, print the appropriate values.
  \item Otherwise, read through the remaining header information and print the data.
  \end{enumerate}
\end{enumerate}

In this implementation, while the code used to produce the data and headers is very similar between software versions for a given board, there are some small differences which make a general program difficult to write. As such, each version is hard-coded, and any changes to the overall structure of the program must be rolled out to all versions. Fortunately, many common tasks such as printing of data are centralized in \texttt{picoquant.c}, so changes to the output format only require modification of a single function.

In principle, the code can be collected into a nicer data-streaming object which masks the translation process and yields only the resulting data stream. This is probably the most convenient way to deal directly with developing custom tools for data processing, but for most purposes passing the data through pipes should be sufficient. If such an interface is desired, the low-level translation functions (found in \texttt{*/*\_v*.c}) should be sufficient when wrapped with higher-level logical routines like those used to determine the board identity and version. The function structure is uniform across all versions and boards, which should simplify the wrapping process.

The remainder of this section is devoted to a discussion of the details important to each board and measurement type. Most of this information can be found in the manuals included with the hardware, but there is a significant amount of information which is documented in more scattered locations, such as the sample data code. This summary includes the details vital to understanding how the raw data are actually translated into the general data streams, and how various design decisions affect the quality and precision of the result.

\subsubsection{A word about external markers}
Many of the timing boards have a feature which allows the insertion of an external timing pulse into the signal, for use in TTTR modes to designate a raster scan or other time-dependent behavior. These records are not handled directly by \picoquant, but instead a message is passed to \stderr{} indicating that such a record exists. If different behavior is desired (perhaps assignment of the marker to a non-existent channel), modify the function \texttt{external\_marker} in \texttt{picoquant.c}. This will cause problems with the other programs, which assume every record originates from the true signal stream, so such an alteration must be accompanied by code which appropriately splices the signal stream, for example by halting collection into a histogram and initiation of a new one.

\subsubsection{T3 timing carries units of histogram bins, not time}

\subsubsection{Translation of T3 to T2 data}
In principle, if the sync source of a T3-mode experiment arrives with perfectly uniform spacing, the pulse number can be said to represent some amount of time, and a T2-like record recovered. To do this, pass the flag \texttt{--to-t2} for an input of T3 data, but consider the implications of how this translation is performed. 

For a frequency $f$ of the arrival of a sync source, pulse number $p_{j}$ and time delay $t_{j}$ on channel $c_{j}$ map as:
\begin{equation}
\left(c_{j}, p_{j}, t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}}{f} + t_{j}\right)
\end{equation}
In practice, this mapping is limited in precision in a few important ways. First, the period $1/f$ is not necessarily an integer multiple of 1\pico\second, and any precision will be lost beyond the decimal. This is not usually a problem because typical sync sources operate at 10\mega\hertz{} at most, for a precision of timing to one part in ten thousand, and a purity of the pulse train to this precision is not typical. Additionally, the timing jitter of most lasers will be well above this threshold, so this is not too great a concern.

A more important concern is that of missed pulses. The T3 data reports the detected pulse number, and if a sync pulse is missed no record will exist. However, translation of any subsequent record to an absolute time will be incorrect by the period $1/f$, confusing matters where such spacing is important. Again, a well-designed system should not have problems beating this limit, but it is the greatest single source of error during the translation.

Collectively, these errors can be expressed as:
\begin{equation}
\left(c_{j}, p_{j}+\delta p_{j}, t_{j} + \delta t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}+\delta p_{j}}{f+\delta f} + \left(t_{j}+\delta t_{j}\right)\right)
\end{equation}

\subsubsection{Timeharp}
The Timeharp is the least sophisticated of the three boards discussed here, and is fundamentally a histogramming board. It features two input channels, and its three modes are:
\begin{itemize}
\item interactive (thd): Collection of a histogram, using channel 0 as the sync and channel 1 as the signal.
\item continuous interactive (thc): Identical to normal interactive mode, except that the histogram is reported at the end of a user-specified time interval, repeating until halted. This feature is used for experiments requiring time resolution of a time-dependent feature, such as a fluctuating fluorescence lifetime. This feature is not supported by the existing software, due to lack of data or interest in using this mode (it is not present in the other timing boards).
\item time-tagged time-resolved (t3r): TTTR mode, equivalent to T3 mode, with channel 0 as the sync and channel 1 as the signal. Instead of reporting the delay time directly, this mode reports the index of the histogram bin an event would fall into. The time delay represented by the delay can be recovered from the header information, but for homogeneity of the treatment of T3-like data this step is not performed automatically.
\end{itemize}

\subsubsection{Picoharp}
The Picoharp features two input channels. Its three modes are:
\begin{itemize}
\item interactive (phd): Standard interactive mode, using channel 0 as the sync and channel 1 as the signal.
\item t2 (pt2): A T2 mode, with both channels treated equally and all pulse arrivals recorded. 
\item t3 (pt3): A T3 mdoe, with channel 0 as the sync and channel 1 as the signal.
\end{itemize}
In both the T2 and T3 mode, internal clocks of limited precision ($<$32 bits) are used to record the passage of time or pulses. As such, many records are devoted to recording the occurrence of an integer overflow. These records are treated by \picoquant{} automatically, producing data streams of the form specified in section~\ref{sec:picoquant_output}.

\subsubsection{Hydraharp}
The Hydraharp features a dedicated sync channel and four input channels. Its three modes are:
\begin{itemize}
\item interactive (hhd): Standard interactive mode, with four separate histograms assigned to  the four input channels.
\item t2 (ht2): A T2 mode, with all channels treated equally, including the sync channel. If the sync channel is active, these events will be recorded, and for convenience \picoquant{} will output each event as arriving on channel 4. This channel index can be altered by modifying value of the global variable \texttt{HH\_SYNC\_CHANNEL} (\texttt{hydraharp.h}) at compilation time. 
\item t3 (ht3): A standard t3 mode.
\end{itemize}
Future versions of the Hydraharp are being developed with extra input channels. If your model features extra channels, it should be sufficient to modify the value of \texttt{HH\_SYNC\_CHANNEL}, as the number of channels and modules is handled dynamically by \picoquant.

\section{Intensity}
\subsection{Purpose}
For T2 and T3 data, it is often useful to group records into fixed time bins and count the number of records in each bin. This program does just that, reporting the intensity at each channel for all data in a time-ordered stream. 

\subsection{Command-line syntax}
\begin{verbatim}
Usage: intensity [-v] [-i file_in] [-o file_out] [-c channels]
                 -w bin_width -m mode

           -v, --verbose: Print debug-level information.
           -i, --file-in: Input file. By default, this is
                          STDIN.
          -o, --file-out: Output file. By default, this is
                          STDOUT.
         -w, --bin-width: Width of the bin, in time or pulses
                          depending on the mode.
              -m, --mode: Stream type. This is either t2 or t3,
                          and the style of the output will be
                          different for each.
          -c, --channels: Number of channels in the stream. By
                          default, this is 2.
         -a, --count-all: Rather than counting records in 
                          distinct time bins, count all records 
                          in the stream.
              -h, --help: Print this message.

       This program assumes the input stream is time-ordered.
       
       If counting all events or printing the last one, the time
       written will be the time of the last event seen.
\end{verbatim}

\subsubsection{Input}
T2 and T3 modes accept data of the form produced by \picoquant, as specified in section~\ref{sec:picoquant_output}.

\subsubsection{Output}
The output for both T2 and T3 modes is of the form:
\begin{verbatim}
lower time limit, upper time limit, 
  channel 0 intensity, channel 1 intensity, ... \n
\end{verbatim}
For T2 mode, the time bin is defined as a number of picoseconds. For T3 mode, the time bin is a number of pulses.

Passing the flag \texttt{--count-all} will ignore the time bins, and instead count all events on each channel as belonging to one large channel. 

\subsection{Examples of usage}
Count into 10\milli\second{} bins.
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 
0,10000000000,555,0
10000000000,20000000000,524,0
20000000000,30000000000,564,0
30000000000,40000000000,536,0
40000000000,50000000000,495,0
50000000000,60000000000,530,0
60000000000,70000000000,514,0
70000000000,80000000000,548,0
80000000000,90000000000,558,0
90000000000,100000000000,565,0
100000000000,110000000000,550,0
110000000000,120000000000,490,0
120000000000,130000000000,559,0
130000000000,140000000000,504,0
140000000000,150000000000,547,0
150000000000,160000000000,537,0
160000000000,170000000000,535,0
170000000000,180000000000,545,0
180000000000,186537236212,344,0
\end{verbatim}
Count all events:
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 \
  --count-all
0,186537236212,10000,0
\end{verbatim}

\subsection{Implementation details}
\label{sec:intensity_implementation}
Each channel can be treated independently, so we can focus on how to handle a single stream of records. 

Given a stream of events with associated arrival times $t_{k}$ and time-ordered time bins with boundaries defined as $[b_{j}, b_{j+1})$, the intensity $I(j)$ of the stream in a given time bin is defined as:
\begin{equation}
I(j) = \left| \braces{t_{k} | t_{k} \in \left[b_{j}, b_{j+1}\right)} \right|
\end{equation}

For a disordered stream of length $N$ and $M$ time bins, it is most efficient to place each entry into a bin in the order they arrive, which means that the true intensity of the signal cannot be known until all elements are processed. Because the bin assignment is continuous and unambiguous, a binary search algorithm can be used to determine the correct bin, in O($\log{(\textnormal{M})}$) for an element. If the spacings are linear, this problem is O(1). Thus, the whole stream can be processed in O(N) time, or O($\textnormal{N}\log{(\textnormal{M})}$) time for the non-linear case. In principle, the disordered stream could be ordered at a cost of O($\textnormal{N}\log{(\textnormal{N})}$), but this extra factor makes the process too expensive for most purposes.

If instead the stream is time-ordered, as is the case for data from \picoquant, it is more efficient to choose a time bin and count the associated elements. In this case, an entry is drawn from the stream, and if it falls in the bin the count for that bin is incremented. If the entry does not fall in the stream, the stream has passed that bin and the count for that bin is reported. In this latter case, the element from the stream is retained until its bin is found. This process is overall of order O(N), because there is only a constant cost associated with moving between the bins, even if they are not regularly spaced.

The algorithm can be expressed more concisely as:
\begin{verbatim}
bin = next(bins)
intensity = 0
time = next(data_stream)

while time != None and bin != None:
    if time in bin:
        intensity += 1
        time = next(data_stream)
    else:
        yield(bin, intensity)        
        intensity = 0
        bin = next(bins)

yield(bin, intensity)
\end{verbatim}

As is evident from this algorithm, the process can be run continuously for a stream, yielding results without the need to process the entire stream.

\section{Correlate}
\label{sec:correlate}
\subsection{A brief mathematical background}
\label{sec:correlate_math}
For several types of experiments, some form of a signal correlation is necessary. These follow the form:
\begin{equation}
\label{eq:correlation}
\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
\end{equation}
where $I_{j}(t)$ are the intensities of some number of signals and the angled brackets indicate an average over time. For some purposes, the autocorrelation of a signal is of interest, where all $I_{j}(t)$ are identical, but in other cases some mixture of signals is of interest, and not necessarily in numerical order. For example, fluoroescence correlation spectroscopy requires the calculation of a second-order autocorrelation of fluorescence intensity, or:
\begin{equation}
\label{eq:g2}
\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
                 {\angles{(I(t)}\angles{(I(t+\tau)}}
             = \frac{\angles{I(t)I(t+\tau)}}
                 {\angles{(I(t)}^{2}}
\end{equation}
where $I(t)$ includes signal across all detection channels. In most cases, calculation of \gn{2} is sufficient, but in this definition we have implicitly limited our discussion to T2-like signals, with one independent variable per signal. In the case of T3-mode signals, we really have two independent variables: pulse number and arrival time. In principle, we could write something like
\begin{equation}
\gn{n}(\rho_{1}, \tau_{1}, \ldots \rho_{n-1}, \tau_{n-1}) = \frac
	{\angles{I_{0}(p, t)\prod_{j=1}^{n-1}{I_{j}(p+\rho_{j},t)I_{j}(p,t+\tau_{j})}}}
	{\angles{I_{0}(p, t)}^{2}\prod_{j=1}^{n-1}{\angles{I_{j}(p+\rho_{j},t)}
	                                       \angles{I_{j}(p,t+\tau_{j})}}}
\end{equation}
where the average is now over all pulse and real time. However, because both pulse and real time are integer spaces, we can just map the times onto two homogeneous dimensions, and perform the correlation \gn{2n} instead. This gives a \gn{n} for every choice of pulses, useful for comparisons of long- and short-time correlations, as in multi-excition spectroscopy.

\subsection{Purpose}
This program calculates the full correlation of a signal, including all autocorrelations and cross-correlations of individual channels, for arbitrary numbers of channels and order. The raw correlation counts are returned as the output, \textit{not the histogrammed correlation}. The histogramming and normalization are left for other programs, such as \texttt{histogram}.

The speed of the calculation scales favorably with the order of correlation, although of course higher orders of correlation require greater numbers of events to build meaningful results. See section~\ref{sec:correlation_implementation} for details of the algorithm.

\subsection{Command-line syntax}
\begin{verbatim}
Usage: correlate [-v] [-i file_in] [-o file_out] [-a] [-b] 
                 [-n number] [-p print_every] [-q queue_size]
                 [-d max_time_distance] [-e max_pulse_distance]
                 [-r] -g order -c channels -m mode

           -v, --verbose: Print debug-level information.
           -i, --file-in: Input file. By default, this is 
                          STDIN.
          -o, --file-out: Output file. By default, this is 
                          STDOUT.
       -p, --print-every: Print the result for multiples of 
                          this number of entries. Default is to
                          print nothing.
              -m, --mode: Stream type. This is either t2 or t3,
                          and the style of the output will be
                          different for each.
        -q, --queue-size: Defines the maximum length of the 
                          circular queue held in memory for
                          processing. By default, this is 100000
 -d, --max-time-distance: Defines the maximum difference in time
                          that two entries can have and still be
                          considered for correlation (t2 and t3).
-e, --max-pulse-distance: Defines the maximum difference in pulse
                          number that two entries can have and 
                          still be considered for correlation 
                          (t3 only).
             -g, --order: Order (g(n)(t1...tn-1)) of the 
             			  correlation to perform. By default this
             			  is 2, the standard cross-correlation of
             			  two channels.
          -c, --channels: Number of channels in the incoming
                          stream. By default, this is 2 
                          (Picoharp).
  -r, --channels-ordered: Organize the output such that the 
                          channels are in order. By default, 
                          this is not performed.
              -h, --help: Print this message.

       This program assumes the input stream is time-ordered.
\end{verbatim}

\subsubsection{Input}
T2 and T3 modes accept data of the form produced by \picoquant, as specified in section~\ref{sec:picoquant_output}.

\subsubsection{Output}
The exact output will depend on the mode and order of correlation, but it always adheres the following form:
\begin{verbatim}
channel 0, channel 1, time 1, ..., channel 2, ... \n
\end{verbatim}
where the times are either times or pulses, and follow the order (pulse, time). Also, the channels here are not necessarily ordered, because the exact order of the signals in the correlation can be of great importance. For example, for a \gn{2} of T2 data:
\begin{verbatim}
channel 0, channel 1, time 1-time 0 \n
\end{verbatim}
for \gn{3} of T2 data:
\begin{verbatim}
channel 0, channel 1, time 1-time 0, 
  channel 2, time 2-time 0 \n
\end{verbatim}
for \gn{3} of T3 data:
\begin{verbatim}
channel 0, channel 1, pulse 1-pulse 0, time 1-time 0,
   channel 2, pulse 2-pulse 0, time 2-time 0 \n
\end{verbatim}

By default, the ordering of the channels is that found in the stream. However, for some applications it is useful to order the channels and record both positive- and negative-time correlations on the same histogram. To account for this, pass the flag \texttt{--channels-ordered} to order the channels and apply the appropriate sign to the time differences.

By default, the program will correlate all entries in a stream. This can easily cause memory problems, so it is recommended that a maximum time distance is specified for T2 data, or a maximum pulse distance for T3 data. A maximum time distance may also be specified for T3 data, but in principle this is unnecessary. Note that all channels are treated equally by these limits. 

Currently, \correlate{} uses a fixed-length circular buffer to store entries, so if errors report that the buffer is too small try changing the length with \texttt{--queue-size}.

\subsection{Examples of usage}
Finding the correlation events for a \gn{2} of T2 data:
\begin{verbatim}
> picoquant --file-in data.ht2 --number 10000 | \
  correlate --channels 4 --mode t2 \
  --max-time-distance 1000
3,2,932
3,0,558
3,1,508
\end{verbatim}
the same, with channels ordered:
\begin{verbatim}
> picoquant --file-in data.ht2 --number 10000 | \
  correlate --channels 4 --mode t2 \
  --max-time-distance 1000 --channels-ordered
2,3,-932
0,3,-558
1,3,-508
\end{verbatim}
\gn{2} of T3 data:
\begin{verbatim}
> picoquant --file-in data.ht3 --number 100 | \
  correlate --channels 4 --mode t3 \
  --max-pulse-distance 1000
3,3,447,14436
1,1,115,-15636
3,2,369,-28240
1,1,986,66088
0,3,240,21380
\end{verbatim}
\gn{3} of T3 data:
\begin{verbatim}
> picoquant --file-in data.ht3 --number 1000 | \
  correlate --channels 4 --mode t3 --order 2 \
  --max-pulse-distance 1000
3,3,10,-44540,0,913,8648
3,0,155,9044,2,353,-792
2,3,128,47316,3,144,42004
2,2,44,-32120,3,300,1380
2,2,44,-32120,2,359,-4924
2,3,300,1380,2,359,-4924
2,3,256,33500,2,315,27196
1,3,460,72356,2,847,20448
3,2,387,-51908,3,603,-43404
2,1,78,-33380,2,323,-60748
1,3,54,-39056,2,239,-60648
3,2,139,39596,3,364,11248
2,2,27,-82228,3,999,-10108
\end{verbatim}

\subsection{Implementation details}
\label{sec:correlation_implementation}
\subsubsection{Definition of the correlation as the order of a set}
As mentioned in section~\ref{sec:correlate_math}, T3 and T2 data are closely related and can be treated similarly. To understand how this is possible, it is worth spending some time considering what information is required to compute the correlation.

In equation~\ref{eq:g2}, the denominator is an average intensity of a signal. This can be computed simply by determining the duration of the signal and the number of counts over that interval, and can be handled by using the result of \intensity{} \texttt{--count-all}. Thus the real problem is the computation of the numerator, which is somewhat imposing at first glance:
\begin{equation}
\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}
\end{equation}
To simplify matters, we will start with the autocorrelation of a signal channel:
\begin{equation}
\angles{I(t)I(t+\tau)}
\end{equation}
In this situation, the signal can be thought of as being composed of some sum of delta functions with peak centers at the times photons arrived. Thus the contribution of any given pair of photons to the correlation at time $\tau$ is nonzero only if the difference of their arrival times is $\tau$. Thus, for a given value of $\tau$ and photon arrival times \braces{t}:
\begin{equation}
\gn{2}(\tau) \propto \left| \braces{(t_{j}, t_{k}) | t_{j},t_{k}\in\braces{t}; t_{j}-t_{k}=\tau} \right|
\end{equation}
This result can be extended to higher orders by enforcing the restriction that a tuple of time differences must be satisfied:
\begin{equation}
\begin{split}
\gn{n}(\tau_{1}, &\ldots \tau_{n-1}) \propto \\
   &\left| \braces{
       (t_{0}, \ldots t_{n-1})
       \left|\begin{split}
       t_{0},\ldots t_{n-1}\in\braces{t}; \\
       (t_{1}, \ldots t_{n-1}) - (t_{0}, \ldots t_{0}) = (\tau_{1}, \ldots \tau_{n-1})
       \end{split}\right.
%       \begin{gather*}
%        \\
%       
%       \end{gather*}
   } \right|
\end{split}
\end{equation}

\subsubsection{Mapping T3 data onto T2-like data}
Now that we have a general expression for calculation of \gn{n}, it is worthwhile to make an aside describing how to map T3 data onto T2-like data for correlation. Consider the basic form of a tuple of $n$ T3 records:
\begin{equation}
\left((c_{0}, p_{0}, t_{0}), \ldots (c_{n-1}, p_{n-1}, t_{n-1})\right)
\end{equation}
which can be mapped isomorphically onto:
\begin{equation}
\left((c_{0}, p_{0}), (c_{0}, t_{0}), \ldots (c_{n-1}, p_{n-1}), (c_{n-1}, t_{n-1})\right)
\end{equation}
which looks like a tuple for T2 records:
\begin{equation}
\left((c_{0}, t_{0}), \ldots (c_{n-1}, t_{n-1})\right)
\end{equation}
Ultimately, a T3 tuple of length $n$ can be mapped onto a corresponding tuple of length $2n$, such that any correlation \gn{n} of T3 data can be treated exactly as a corresponding correlation \gn{2n} of T2 data.

\subsubsection{Correlation of the time-ordered stream}
As with \intensity, \correlate{} expects a time-ordered stream (see section~\ref{sec:intensity_implementation}). 

% For a correlation of order $n$, every unique combination of $n$ elements of the stream can contribute to \gn{n}, so the full correlation of stream of lengh $N$  costs O(N$^{n}$) to compute. This is reduced for a fixed window width to approximately O(Nw$^{n-1}$) for a window of width w, for reasons that will become clear shortly.




\section{Histogram}

\subsection{Purpose}
\subsection{Command-line syntax}
\begin{verbatim}
\end{verbatim}

\subsubsection{Input}
\subsubsection{Output}

\subsection{Examples of usage}
\subsection{Implementation details}


\section{Applications}
\subsection{Time-dependent photoluminescence lifetime}
\subsection{Bunching and antibunching}
\subsection{Fluorescence blinking}

\begin{appendix}
\section{Mathematical notation}
\label{sec:notation}
\end{appendix}

\end{document}
