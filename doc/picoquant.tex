\documentclass{article}

\usepackage[squaren]{SIunits}
\usepackage{amsmath,amsfonts}
\usepackage{appendix}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{url}

\newcommand{\cps}{\textnormal{cps}}
\newcommand{\braces}[1]{\ensuremath{\left\lbrace #1 \right\rbrace}}
\newcommand{\angles}[1]{\ensuremath{\left\langle #1 \right\rangle}}
\newcommand{\brackets}[1]{\ensuremath{\left[ #1 \right]}}
\newcommand{\parens}[1]{\ensuremath{\left( #1 \right)}}
\newcommand{\setbuilder}[2]{\ensuremath{\braces{#1 \left| #2 \right.}}}
\newcommand{\stdin}{\texttt{stdin}}
\newcommand{\stdout}{\texttt{stdout}}
\newcommand{\stderr}{\texttt{stderr}}
\newcommand{\picoquant}{\texttt{picoquant}}
\newcommand{\intensity}{\texttt{intensity}}
\newcommand{\correlate}{\texttt{correlate}}
\newcommand{\histogram}{\texttt{histogram}}
\newcommand{\gn}[1]{\ensuremath{g^{(#1)}}}
\newcommand{\integers}{\ensuremath{\mathbb{Z}}}
\newcommand{\wholes}{\ensuremath{\mathbb{N}}}
\newcommand{\reals}{\ensuremath{\mathbb{R}}}
\newcommand{\rationals}{\ensuremath{\mathbb{Q}}}
\renewcommand{\vec}{\boldsymbol}
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\eV}{\textnormal{eV}}
\newcommand{\channel}{\ensuremath{c}}
\newcommand{\channels}{\ensuremath{C}}
\newcommand{\Channel}{\ensuremath{\mathcal{C}}}
\newcommand{\Time}{\ensuremath{\mathcal{T}}}
\newcommand{\photon}{\ensuremath{\gamma}}
\newcommand{\photons}{\ensuremath{\Gamma}}
\newcommand{\Pulse}{\ensuremath{\mathcal{P}}}
\newcommand{\integrationtime}{\ensuremath{\Xi}}
\newcommand{\timewindow}{\ensuremath{\xi}}
\newcommand{\resolution}{\ensuremath{\epsilon}}
\newcommand{\Index}{\ensuremath{\mathcal{J}}}
\newcommand{\Histogram}{\ensuremath{\mathcal{H}}}
\newcommand{\ceil}[1]{\ensuremath{\left\lceil #1\right\rceil}}
\newcommand{\GN}{\texttt{gn}}
\newcommand{\tstart}{\integrationtime\upminus}
\newcommand{\tstop}{\integrationtime\upplus}
\newcommand{\correlationset}{\ensuremath{G}}
\newcommand{\upplus}{\ensuremath{^{(+)}}}
\newcommand{\upminus}{\ensuremath{^{(-)}}}
\newcommand{\nth}{\ensuremath{n}\textnormal{th}}
\newcommand{\closedopenrange}[2]{\ensuremath{\left[#1, #2\right)}}


\title{Picoquant: General-purpose tools for interacting with photon-arrival data, and for performing $n$th order correlations \\ 
v1.5}
\author{Thomas Bischof \\ \texttt{tbischof@mit.edu} \\ \url{http://tsbischof.dyndns.org}}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
 
\section{Introduction}
\subsection{The layout of this document}
This document is laid out in roughly three parts:
\begin{enumerate}
\item Overview of terminology and methods
\item Documentation for each program
\item Applications of the software to real problems
\end{enumerate}
In the chapters devoted to the various programs, the documentation is divided further:
\begin{enumerate}
\item Command-line syntax
\item Theoretical overview of the purpose of the program
\item Details of the implementation
\end{enumerate}
If you are familiar with the details of photon correlation methods, you can safely skip to the sections describing the different programs, and to the discussion of their applications. 

\subsection{A (very) brief overview of photon-arrival timing}
In single-molecule spectroscopy, single-photon detectors are often used to perform time-resolved experiments. Detectors such as silicon-based avalanche photodiodes (APDs) can be used to detect the arrival time a photon with about 500\pico\second{} resolution, and can detect up to $10^{7}$ photons per second before saturation, abbreviated as 10\mega\cps{} hereafter (counts per second). Hardware capable of resolving these arrival times is of great use for revealing time-dependent structure to the photon stream, such as intensity fluctuations and bunching, so various hardware designs have been developed to permit such measurements.

One line of instruments is the timing hardware produced by Picoquant GmBH, such as the Timeharp, Picoharp, and Hydraharp. These modules are capable of detecting pulse arrivals on multiple input channels with a resolution of as little as 1\pico\second, and operate in a few distinct modes:
\begin{enumerate}
\item Interactive (histogram): one input channel is designated as a sync source, representing a clock-starting signal. On the other channels, pulse arrival times are recorded relative to this clock source, and the times binned into a histogram. 
\item Time-tagged time-resolved (TTTR): 
	\begin{enumerate}
	\item T2: all channels are treated equally, and all pulse arrival times relative to the start of the experiment are recorded. 
	\item T3: this is similar to histogram mode, but instead of binning the arrival times, the sync event number and relative arrival time are both recorded.
	\end{enumerate}
\end{enumerate}

In all cases, the times are discrete and represent some number of cycles of a clock, so all times must be treated as integers representing some number of picoseconds. This has important effects on the definition of time bins for histograms, and where appropriate some time will be devoted to discussing these factors. 

Considering these distinct modes, it is important to spend some time discussing their uses, and how their data should be handled.

\subsection{Data collection modes}
\label{sec:modes}
\subsubsection{Interactive (histogram)}
A common experiment for studying fluorophores is to measure the time dependence of their response to an excitation. For example, a pulsed laser can be used to excite a sample, and the resulting fluorescence detected by an APD. Because single-photon detectors are limited to detection of a single photon at once, to reconstruct the decay curve it is necessary to average the result over many pulses of the laser, binning the arrival times of the emitted photons relative to that of the laser. If measuring this time-averaged behavior is sufficient, then the interactive histogram mode is used to perform all of this collection and binning on the hardware without any post-processing. 

Consequently, interactive data consists of $N$ unique arrival time bins with boundaries $\parens{b_{j}\upminus, b_{j}\upplus}$ and the number of counts $n_{j}$ associated with that bin, so the data can be represented by the set:
\begin{equation}
\braces{\parens{\parens{b_{j}\upminus, b_{j}\upplus}, n_{j}}}
\end{equation}
The exact choice of where the boundaries lie has some effect on the resulting histogram, but this performed in the hardware and presumably represents $t\in\left[b_{j}, b_{j+1}\right)$. This choice is not detailed in the manuals for the hardware, but it is of little practical importance; typical detectors have two orders of magnitude more timing jitter than the timing hardware, so the exact definition of the histogram bin has a negligible effect.

\subsubsection{T2}
In T2 mode, all input channels are connected to photon detectors. At the start of the experiment, an internal clock is reset and started, providing a master timing reference. As a pulse arrives, the machine emits data encoding the channel and time of arrival, so the data follow the form:
\begin{equation}
\braces{(c, t)}
\end{equation}
for a channel $c$ and arrival time $t$ of a photon.
%Typically, these data are used to examine time-dependent behavior, such as intensity fluctuations, particularly when the excitation source is continuous-wave. These data are also useful for calculation of correlation functions such as:
%\begin{equation}
%\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
%	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
%	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
%\end{equation}
%The details of this calculation will laid out later in section~\ref{sec:correlate}, but one use of the $g^{(2)}(t)$ is to determine the number of emitters present in a signal. For example, a single emitter emitting one photon at any time will exhibit so-called antibunching behavior, where $g^{(2)}(t)\rightarrow 0$ for $t\approx 0$, indicating a diminished probability of seeing two successive photon emissions ($g^{(n)}(\braces{t_{j}})=1$ indicates no correlation). Correlations of higher order ($n\ge 3$) have their own uses, but quickly become computationally expensive for reasons which will become clear later.

\subsubsection{T3}
T3 mode is closest in character to the interactive mode, except that, instead of binning the photon arrival times on the hardware, the arrivals are recorded directly for later examination, as in T2 mode. This gives a data set of the form:
\begin{equation}
\braces{(c, p, t)}
\end{equation}
for channel $c$, sync pulse number $p$, and relative arrival time $t$. Indeed, by defining temporal bins and histogramming the $t$, the result from the interactive mode can be reproduced exactly.

\paragraph{Mapping T3 onto T2 data}
\label{sec:t3_to_t2}
For signals produced by regular excitation it is possible to convert T3 data to T2 data. For example, consider a sample excited by a laser with repetition rate $f$. The pulse number therefore defines a time $1/f$, and $t$ acts as a correction to this time:
\begin{equation}
\left(c, p, t\right) \rightarrow \left(c, \frac{p}{f} + t\right)
\end{equation}
Of course, this conversion is not necessarily perfect. For example, sync pulses may be missed or overcounted, introducing a cumulative error $\delta p$, the frequency of the sync pulse might deviate with some jitter $\delta f$, or the timing of the arrival might have some jitter $\delta t$, such that the true expression is:
\begin{equation}
\left(c, p+\delta p, t + \delta t \right)
      \rightarrow \left(c, \frac{p+\delta p}{f+\delta f} + t+\delta t\right)
\end{equation}
For a well-designed system these errors should not be very large, but if an application requires precision approaching that of the timing hardware they can be quite important. 

% However, this mode also allows for studying time dependence and correlation in the data, as with T2 mode. In principle, any data collected in T3 mode can be transformed into T2 mode data if the sync source is regular, as the pulse number will represent some amount of time in the experiment, but there are subtle hardware and numerical issues (discussed later) which limit the practicality of this transformation.
%
%Uses of this mode include the study of the time-dependent fluoresence lifetime of single molecules, which can switch between distinct states under various conditions. Correlation methods can also reveal important behavior, but again this will be discussed later.

\subsection{Correlation techniques}
A number of techniques involving the correlation of one or more signals exist, and their use in fluorescence microscopy requires that we be able to calculate correlation functions of the following form:
\begin{equation}
\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
	{\angles{I(t)\prod_{j=1}^{n-1}{I(t+\tau_{j})}}}
	{\angles{I(t)}^{n}}
\end{equation}
The details of calculating this function will be laid out in section~\ref{sec:math_background}. For now, note that the problem can be divided into three distinct parts:
\begin{enumerate}
\item Calculation of \angles{I_{j}(t)}
\item Finding correlation events
\item Histogramming correlation events
\end{enumerate}

\subsection{General design principles}
Analysis of these timing data can be roughly described as follows:
\begin{enumerate}
\item Produce a stream of photon events
\item Condition the stream by correlation, removal of extraneous information, homogenization of the detection channels, etc.
\item Collect the result to form some histogram of events.
\end{enumerate}
As such, these three phases are handled by distinct programs, which act as filters of a data stream by reading in values and outputting the appropriate new values. These streams are ultimately streams of binary data, but for any program the stream may be defined by the standard data streams (\stdin, \stdout) or by some file containing the data. 

For time-tagged modes, times are represented as integer multiples of 1\pico\second, although only the initial data streamer is actually aware of units; the conditioning and collection routines operate on time as an integer, without regard for its units.

All programs are designed to operate on a data stream until that stream terminates, so any division of a data stream should be handled by a separate program and the result fed into a distinct instance of the handler. 

The main processing software (\picoquant, \intensity, \correlate, \histogram) is written in the C programming language, using the C99 standard. Where necessary, the definitions of data types have been defined to be of fixed width, but otherwise the definitions are those minimal for handling reasonable values. For example, in T2 mode time is defined as a signed 64-bit integer, representing $\approx 10^{19}\pico\second$, or $10^{7}\second$, or $106$ days. Pulses are counted as signed 64-bit integers, limiting their total to several thousand years of 10\mega\hertz{} pulsed laser excitation. With luck, your experiments will not exceed these values. 

In addition to the C code, several analysis scripts written in Python have been provided in \texttt{scripts/}. These include routines to read in the outputs of most of the processing software, generate correlation functions, plot lifetime data, and so on. 

All programs will display command-line syntax when the flag \texttt{-h} or \texttt{--help} is given. The C programs have been tested most thoroughly on 32-bit and 64-bit Linux systems with the GNU C compiler, but in principle should work on any system with a C99-compliant compiler. Non-standard libraries are not used, to limit portability issues. A Makefile is present in the \texttt{src} directory which should be sufficient for compiling the software, although it will require some modification for different compiler configurations.

The Python programs have been tested primarily with version 2.7 on the same systems described above, but should also work in versions 3.x.

\section{The mathematics of calculating \gn{n}}
\label{sec:math_background}
This section will detail the mathematics of calculating correlation functions \gn{n}. If you are familiar with the results, you can safely skip this section, but do note that the correlation of photon events is in many ways distinct from a standard signal correlation.

If you are not familiar with notation such as
\begin{align}
c &= \braces{(a,b)|a,b\in\integers;~a/b\in\integers} \\
F&:\wholes\times\integers\rightarrow\reals \\
&\sum_{z\in\integers_{n}}{z^{2}} \\
&A\cap B
\end{align}
you should read appendix~\ref{sec:notation} before reading the remainder of this section.

\subsection{Definition of the correlation function}
\label{sec:correlation_function}
A signal $I(t)$ is a function of real time which returns non-negative values\footnote{Correlations can be defined for negative-valued functions, but for our purposes non-negative functions are the most physically meaningful.}:
\begin{equation}
I:\reals\rightarrow\reals^{*}
\end{equation}
In practice such a function may represent a physical quantity such as voltage, and we will develop our understanding of photon correlations by developing first an understanding of how to correlate real-valued functions. 

The simplest non-trivial correlation of a function is the autocorrelation, which measures the average predictability of the value of the function for a time $t+\tau$, given its value at $t$. By this we mean that a function is more, less, or equally likely to increase than decrease after the time delay. Formally, this is a function which maps a signal to a function mapping time vectors to scalar, and  can be calculated as
\begin{equation}
\gn{2}(I(t);\tau) = \frac{\angles{I(t)I(t+\tau)}}
                    {\angles{I(t)}\angles{I(t+\tau)}}
\end{equation}
where the angled brackets indicate an average over all values of $t$. Implicit in this definition is the assumption that $I(t)$ have a non-zero value for some time, because the average must be non-zero for the result to be well-defined. Practically, this imposes the requirement that a signal must exist, so it is not too onerous. Because we will typically define $I(t)$ in context, we will drop it from the notation 
\begin{equation}
\label{eq:autocorrelation}
\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
                    {\angles{I(t)}\angles{I(t+\tau)}}
\end{equation}
This formula can be interpreted as a measure of the periodic structure of $I(t)$: the denominator represents the average density of signal over a volume in phase space, while the numerator represents the density of events where the signal has some non-random behavior relative to all origins of time. 
%Here, $\gn{2}>1$ indicates supercorrelation, that the function is more likely than not to increase in value after a time delay $\tau$. If $\gn{2}<1$, the function is more likely than not to decrease in value after a time delay $\tau$. And in the middle, if $\gn{2}=1$, the function has equal probability to increase, decrease, or remain constant. The meaning of the exact magnitude of $\gn{2}(\tau)$ can be discussed in the context of a particular function, but these general principles should always apply.

In many cases, an autocorrelation is an oversimplification of a signal, and it is useful to be able to compare the cross-correlations of two or more channels instead. For example, if our function $I$ is endowed with a second dimension indicating the identity of a detection channel from the set $C$ of detection channels, it takes the form
\begin{equation}
I:C\times\reals\rightarrow\reals^{*}
\end{equation}
where $\times$ is the Cartesian product of elements from $\channels$ and $\reals^{*}$. For example, if $\channels=\braces{0, 1}$, elements of $\channels\times\wholes$ take the form of 2-tuples such as (0, 10), (1, 17), (0, 0), and so on. Under this notation, $I$ is now a function of two variables and follows the form $I(c, t)$. For clarity of future notation, we will include the channel variable as a subscript:
\begin{equation}
I_{c}(t)\equiv I(c,t) 
\end{equation}
Given this, we can separate the signal $I$ into a sum of signals over all channels:
\begin{equation}
I(t) = \sum_{c\in C}{I_{c}(t)}
\end{equation}
Under the definition of an autocorrelation as in equation~\ref{eq:autocorrelation}, we can substitute this new value and expand the result to obtain:
\begin{align}
\label{eq:signal_g2}
\gn{2}(\tau) &= \frac
     {\angles{
       \left(\sum_{\channel\in\channels}{I_{c}(t)}\right)
       \left(\sum_{\channel\in\channels}{I_{c}(t+\tau)}\right)}}
     {\angles{\sum_{\channel\in\channels}{I_{c}(t)}}
      \angles{\sum_{\channel\in\channels}{I_{c}(t+\tau)}}} \\
             &= \frac{\angles{\sum_{\vec{\channel}\in\channels}{
                             I_{c_{0}}(t)I_{c_{1}}(t+\tau)}}}
                     {\left(\sum_{\channel\in\channels}{\angles{I_{c}(t)}}\right)
                      \left(\sum_{\channel\in\channels}{\angles{I_{c}(t+\tau)}}\right)}
%\gn{2}(\tau) &= \frac{\angles{\left(\sum_{\channel\in\channels}{I_{c}(t)}\right)
%                              \left(\prod_{j=1}^{n-1}{
%                                          \sum_{\channel\in\channels}{I_{c}(t+\tau_{j})}}\right)}}
%                     {\angles{\sum_{\channel\in\channels}{I_{c}(t)}}
%                      \prod_{j=1}^{n-1}{\angles{\sum_{\channel\in\channels}{I_{c}(t+\tau_{j})}}}} \\
%             &= \frac{\angles{\sum_{\vec{\channel}\in\channels}{
%                             \left(I_{c_{0}}(t)\prod_{j=1}^{n-1}{I_{c_{j}}(t+\tau_{j})}\right)}}}
%                     {\angles{\sum_{\channel\in\channels}{I_{c}(t)}}^{n}}
\end{align}
where $\vec{\channel}\equiv(\channel_{0},\channel_{1})\in\channels^{2}$ indicates 2-tuple elements of the set $\channels\times\channels$. We see that, if $\channels$ contains a single element (we have only one detection channel), the function returns to the form shown in equation~\ref{eq:autocorrelation}. Note also that we can consider a single cross-correlation term, though these are distinct from the terms in the autocorrelation sum:
\begin{equation}
\gn{2}_{(c_{0},c_{1})}(\tau)=\frac{\angles{I_{c_{0}}(t)I_{c_{1}}(t+\tau)}}
                                                {\angles{I_{c_{0}}(t)}\angles{I_{c_{1}}(t+\tau)}}
\end{equation}
If we ignore the normalization and retain just the cross term, we see that each cross-correlation contains the information necessary for reconstructing the full autocorrelation, though we must have knowledge of the individual average intensities to do so. As such, we will focus most of our attention on calculating the cross-correlation terms.

As an aside, note that the interchange of two channels is equivalent to inversion of their relative time delay:
\begin{align}
\gn{2}_{(c_{0},c_{1})}(\tau)&=\frac{\angles{I_{c_{0}}(t)I_{c_{1}}(t+\tau)}}
                                                {\angles{I_{c_{0}}(t)}\angles{I_{c_{1}}(t+\tau)}} \\
                            &=\frac{\angles{I_{c_{0}}(t-\tau)I_{c_{1}}(t)}}
                                                {\angles{I_{c_{0}}(t-\tau)}\angles{I_{c_{1}}(t)}} \\
                            &= \gn{2}_{(c_{1}, c_{0})}(-\tau)
\end{align}
This relationship implies that, while cross-correlations may be asymmetric about $\tau=0$, the full autocorrelation must be symmetric. 

Now that we have generalized this definition to an arbitrary number of channels, we can also generalize the correlation to an arbitrary order $n$ by drawing cross-correlation terms $\vec{\channel}\in\channels^{n}$:
\begin{equation}
\label{eq:gn}
\gn{n}(\tau_{1},\ldots\tau_{n-1}) = 
     \frac{\sum_{\vec{\channel}\in\channels^{n}}
                {\angles{I_{\channel_{0}}(t)\prod_{j=1}^{n-1}{I_{\channel_{j}}(t+\tau_{j})}}}}
     {\left(\sum_{\channel\in\channels}{\angles{I_{\channel}(t)}}\right)
      \left(\prod_{j=1}^{n-1}
                 {\sum_{\channel\in\channels}
                       {\angles{I_{\channel}(t+\tau_{j})}}}\right)}
\end{equation}
The interpretation of this equation is the same as before, except that the correlation is measured as a density in $n$-dimensional space.

\subsubsection{Examples of correlations of functions}
To become more familiar with the behavior of these correlation functions, we should evaluate them for a few familiar functions. For example, for $I(t)=1+\sin{(t)}$:
\begin{align}
\label{eq:sine_correlation}
\gn{2}(\tau) &= \frac{\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\left(1+\sin{(t+\tau)}\right)\,dt}}
                     {\left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\,dt}\right)
                      \left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t+\tau)}\right)\,dt}\right)} \\
             &= 1 + \frac{1}{2}\cos{(\tau)}
\end{align}
For, this result says that, given that our function at some value at time $t$, after a small time delay $\tau\approx 0$ the value is likely to have increased ($\gn{2}=1.5$). After a delay of $\tau=\pi/2\textnormal{ or }3\pi/2$, the function is equally likely to have increased as decreased, and its correlation is therefore indistinguishable from that of a randomly-distributed function.

Moving on, consider a signal composed of two sine waves:
\begin{align}
I_{0}(t) &= 1+\sin(t) \\
I_{1}(t) &= 1+\sin(2t) \\
I(t) &= I_{0}(t)+I_{1}(t)
\end{align}
We can calculate the full autocorrelation:
\begin{align}
\gn{2}(\tau) = 2 + \frac{1}{4}\cos(\tau) + \frac{1}{4}\cos(2\tau)
\end{align}
or individual cross-correlations:
\begin{align}
\gn{2}_{(0,0)}(\tau) &= 1+\frac{1}{2}\cos(\tau) \\
\gn{2}_{(0,1)}(\tau) = \gn{2}_{(1,0)}(\tau) &= 1 \\
\gn{2}_{(1,1)}(\tau) &= 1+\frac{1}{2}\cos(2\tau)
\end{align}
Calculation of higher-order correlations is also possible, though the results quickly become quite verbose:
\begin{align}
\gn{3}(\tau) &= 1
               + \frac{1}{8}\cos(\tau_{1})
               + \frac{1}{8}\cos(2\tau_{1})
               + \frac{1}{8}\cos(\tau_{1}-\tau_{2}) \nonumber\\
            &  + \frac{1}{8}\cos(2(\tau_{1}-\tau_{2}))
               + \frac{1}{8}\cos(\tau_{2})
               + \frac{1}{8}\cos(2\tau_{2})  \nonumber \\
            &  - \frac{1}{32}\sin(\tau_{1}-2\tau_{2})
               - \frac{1}{32}\sin(2\tau_{1}-\tau_{2})
               + \frac{1}{32}\sin(\tau_{1}+\tau_{2})
\end{align}

\subsection{Photon arrivals can be represented by $\delta$-functions}
To begin to see how we may calculate correlations of photon arrival times, consider the essential character we must capture: any given detection channel $c$ may detect up to a single photon at any time, and that detection event occurs at some fixed times $t$. As such, we can uniquely define a photon as an element $\photon$ by its channel and arrival time:
\begin{equation}
\photon=(c,t)\in\channels\times\reals
\end{equation}
Furthermore, given a set of photons $\photons$, we can define the signal consisting of all detected photons as a sum over $\delta$ functions\footnote{$\delta(\vec{x})=0$ if and only if $\vec{x}=\vec{0}$, and $\int_{-\infty}^{\infty}{\delta(\vec{x})\,d\vec{x}}=1$.}:
\begin{equation}
\label{eq:delta_function_signal}
I_{\channel}(t) = \sum_{\photon\in\photons}
                       {\delta\left(\channel-\Channel(\photon),t-\Time(\photon)\right)}
\end{equation}
where $\Channel$ is a function of a photon which returns the detection channel the photon arrived on, and $\Time$ is a similar function which returns arrival time. To simplify the notation, we can define a subset of photons associated with each channel:
\begin{equation}
\photons_{\channel} = \setbuilder{\photon}{\photon\in\photons;~\Channel(\photon)=\channel}
                      \subseteq\photons
\end{equation}
where the set builder notation denotes the elements of a set and the conditions they must satisfy for inclusion in the set. In long form, the set $\photons_{\channel}$ is the set of all photons in $\photons$ which arrived on channel $\channel$. As before, we can recover the full signal by the union of all channel signals:
\begin{equation}
\photons = \bigcup\limits_{\channel\in\channels}{\photons_{\channel}}
\end{equation}
Because we have discretized the signal into a set of photons, we can more efficiently describe operations on the signal as counting subsets of the signal. For example, the autocorrelation of the signal $\photons$ can be calculated by integrating the associated $\delta$-functions:
\begin{align}
\gn{2}(\tau) &= \frac{\int{\left(\sum_{\photon\in\photons}{\delta(t - \Time(\photon))}\right)
                    \left(\sum_{\photon\in\photons}{\delta(t+\tau-\Time(\photon))}\right)dt}}
                   {\left(
                       \int{\brackets{
                                \sum_{\photon\in\photons}
                                     {\delta(t-\Time(\photon))}}dt}\right)
                    \left(
                       \int{\brackets{
                                \sum_{\photon\in\photons}
                                     {\delta(t+\tau-\Time(\photon))}}dt}\right)}
\end{align}
but the same result can be expressed much more simply by counting events:
\begin{equation}
\label{eq:photon_correlation_prop}
\gn{2}(\tau) \propto \abs{\setbuilder
                                  {(\photon_{0},\photon_{1})}
                                  {\left|\begin{aligned}
                                        \photon_{0}\in\photons;\\
                                        \photon_{1}\in\photons;\\
                                        \abs{\braces{\photon_{0},\photon_{1}}}=2;\\
                                        \Time(\photon_{1})-\Time(\photon_{0})=\tau;
                                  \end{aligned}\right.}}
\end{equation}
where $(\photon_{0},\photon_{1})$ represents a pair of photons, and the third condition indicates that the two photons are not identical. This restriction helps distinguish the contribution of distinct pairs of photons to the correlation at $\tau=0$, which would otherwise be a sum of all photons and all photon pairs arriving simultaneously. The normalization factor is not quite as straightforward to calculate as for the continuous case, so we should spend some time simplifying the problem until that calculation becomes practical.

\subsection{Correlation over a finite time range}
In a physical experiment, time has a well-defined beginning and end: time begins when the experiment starts, and ends when it stops. Here the term experiment can mean a complete experiment or some subset of time in a larger measurement, but ultimately the important result is that the time range of the experiment is some range of time:
\begin{equation}
\integrationtime = [\tstart,\tstop)\subset\reals
\end{equation}
where the bracket notation indicates that the subset contains all values at least as great as $\tstart$ and less than $\tstop$. Moreover, we will typically divide time into equally-spaced blocks, such that each block of experiment time can be indexed by some whole number:
\begin{equation}
\integrationtime = \braces{\tstart,\tstart+\Delta t,\ldots} 
       \rightarrow \braces{0,1,\ldots} = \integers_{N}
\end{equation}
where $N=\abs{\integrationtime}$ is the number of time blocks in the measurement. As such, any signal $I(t)$ can be treated as a function of whole time:
\begin{equation}
I:\wholes\rightarrow\reals^{*}
\end{equation}
More simply, because there are a finite number of values for which $I(t)$ is defined, we can treat it as a vector in signal space:
\begin{equation}
I(t) \equiv \vec{I}\in \left(\reals^{*}\right)^{N}
\end{equation}
where each dimension of the vector space represents the possible values $I(t)$ may have for a particular time block. These dimensions are indexed as $\vec{I}(t)$.

Given this, the autocorrelation can be defined as a sum over all times in the experiment:
\begin{align}
\gn{2}(\tau) &= \frac{\frac{1}{N}\sum_{j=0}^{N-1}{\vec{I}(j)\vec{I}(j+\tau)}}
                     {\parens{\frac{1}{N}\sum_{j=0}^{N-1}{\vec{I}(j)}}
                      \parens{\frac{1}{N}\sum_{j=0}^{N-1}{\vec{I}(j+\tau)}}} \nonumber \\
\label{eq:discrete_g2} &= \frac{\parens{N}\sum_{j=0}^{N-1}{\vec{I}(j)\vec{I}(j+\tau)}}
                    {\parens{\sum_{j=0}^{N-1}{\vec{I}(j)}}
                     \parens{\sum_{j=0}^{N-1}{\vec{I}(j+\tau)}}}
\end{align}
Note that the index of the signal extends past those for which $\vec{I}$ is defined in the time-shifted signal. This can be reconciled by defining $\vec{I}(t)=0$ for values of $t$ outside \closedopenrange{0}{N}. Thus the time-shifted signal has an increasingly decaying intensity as the time delay increases, accounting for the fact that we have no information about the signal outside the bounds of our integration window.
%Note that the normalization factor corresponding to the averaging dimension is limited to the range of values in the summation. This results from the fact that, with finite boundaries to time, not all times are valid for the correlation, and inclusion of these times underestimates the true value of \gn{2}. This not an important effect when $\tau\ll N$, but for $\tau\approx N$ the correction is significant, and we will explicitly include it to ensure complete accuracy (at a cost of clarity).

Now that we have a method for calculating the discrete correlation function, we should consider how this will be performed for photons. One method would be to choose the subdivisions of time $\timewindow$, and define $I(\timewindow)$ to be the number of photons found with arrival times in $\timewindow$. Depending on the definition of $\timewindow$ this could be any whole number up to the number of photons in the set, and equation~\ref{eq:discrete_g2} could be applied. However, this is inefficient: for practical measurements, $I(t)=0$ for a significant percentage of times $t$, and we must spend significant effort summing over zero-valued terms. As such, we will recast the problem as counting elements in a set:
\begin{equation}
\label{eq:photon_g2}
\gn{2}(\tau) = \frac{\parens{\abs{\integrationtime}}
                     \abs{\setbuilder{(\photon_{0},\photon_{1})}
                                     {\begin{aligned}
                                      \photon_{0}\in\photons;\\
                                      \photon_{1}\in\photons;\\
                                      \abs{\braces{\photon_{0},\photon_{1}}}=2;\\
                                      \Time(\photon_{1})-\Time(\photon_{0})=\tau;
                                      \end{aligned}}}}
                    {
                             \abs{\setbuilder{\photon}{\begin{aligned}
                                                      \photon\in\photons;\\
                                                      \Time(\photon)-\tau\in\integrationtime
                                                      \end{aligned}}}
                             \abs{\setbuilder{\photon}{\begin{aligned}
                                                      \photon\in\photons;\\
                                                      \Time(\photon)+\tau\in\integrationtime
                                                      \end{aligned}}}}
\end{equation} 
One final factor we have left out is the resolution of the experiment. When converting from real to whole time we implicitly assigned each subset $\timewindow$ to some whole number index, such that the time delay $\tau$ really represents a range of possible delays. In the final formula, we will include this factor, but for now we will leave it out for simplicity.

\subsection{The full \gn{n} for photon correlation}
Before we extend the result of equation~\ref{eq:photon_g2} to multiple time dimensions, it is worthwhile to write the general form of the result whose terms we must calculate. Starting with the definition of the correlation function, we note that the basic form of \gn{n} is:
\begin{equation}
\gn{n} = \frac{\parens{\textnormal{density of correlation events}}}
              {\parens{\textnormal{density of randomly-distributed correlation events}}}
\end{equation}
Recasting these general ideas to the photon-counting terminology we have developed, we can define a few descriptive terms. First of all, we must define the set of times accessible to a given dimension of the correlation. That is, for a given time difference between two photons, there will be some subset of times in the experiment where no correlation event can possibly exist, and inclusion of these times in any normalization will underestimate the normalized value. For a given tuple of time delays $\vec{\tau}$ and a particular time delay $\tau_{j}$, we will denote this set:
\begin{equation}
\integrationtime_{\vec{\tau},\tau_{j}}
\end{equation}
Next, to determine the average number of randomly-distributed correlation events, we must know the average probability of finding a photon at any given time. This can be determined by counting the photons contributing to the correlation and dividing by the amount of time over which they were found, so denote the set of such photons:
\begin{equation}
\photons_{\vec{\tau},\tau_{j}}
\end{equation}
Lastly, to determine the density of correlation events we must count the number of correlation events in a given volume of time-delay space. By specifying $\tau$ we are really declaring that a photon arrived in some unit of time resulting from the resolution of the measurement, so the spatial normalization is implicit for now. As for the correlation events, we these are determined by the given time delays and the particular channels in the cross-correlation, so denote this set:
\begin{equation}
\correlationset_{\vec{\tau},\vec{\channel}}
\end{equation}
In general we may wish to consider some number of possible time delays when calculating these sets, as in a histogram. We will denote each set of time delays:
\begin{equation}
\resolution = \left[\resolution\upminus,\resolution\upplus\right)
\end{equation}
These effective time resolutions affect the volume of phase space under consideration, and must act to normalize the correlation set to return an average number of correlation events per volume phase space. 

Assembling these, the complete correlation function takes following form:
\begin{equation}
\label{eq:gn_full}
\gn{n}\parens{\vec{\resolution}} = \parens{\frac{\abs{\integrationtime}^{n}}
                                                {\prod_{j=0}^{n-1}
                                                       {\abs{\photons_{
                                                                 \vec{\resolution},
                                                                 \resolution_{j}}}}}}
                            \parens{\frac{\sum_{\vec{\channel}\in\channels^{n}}
                                               {\abs{\correlationset_{\vec{\resolution},
                                                                      \vec{\channel}}}}}
                                         {\prod_{j=0}^{n-1}{\abs{\resolution_{j}}}}}
\end{equation}

Now that we have defined each of these terms, we can turn our focus to calculating them. First, the set $\integrationtime_{\vec{\resolution},\resolution_{j}}$ is defined as the range of times accessible to the $j$th dimension of the correlation. If we extend the prior arguments to multiple dimensions, we find this to be:
\begin{equation}
\integrationtime_{\vec{\resolution},\resolution_{j}} = 
   \left[
   \integrationtime\upminus + \resolution_{j}\upminus - \min{\parens{\vec{\resolution}\upminus}},
   \integrationtime\upplus + \resolution_{j}\upplus - \max{\parens{\vec{\resolution}\upplus}}
   \right)
\end{equation}
To deconstruct this, start by noting that this subset starts as the full integration time; in the absence of time delays, all times can host a correlation event. Next, the set is augmented by $\resolution_{j}$, which moves the upper and lower bounds to values representing the displacement appropriate for the specified dimension. Finally, the extreme bounds are used to limit the range to just those times satisfying the bounds of all dimensions. This result is easier to understand graphically, try drawing the blocks and see how they fit into the full block of integration time.

Next, the set of photons accessible in these times is:
\begin{equation}
\photons_{\vec{\resolution}, \resolution_{j}} = 
   \setbuilder{\photon}
              {\photon\in\photons;~
               \Time\parens{\photon}\in\integrationtime_{\vec{\resolution},\resolution_{j}}}
\end{equation}
Finally, the set of all correlation events is as defined in equation~\ref{eq:photon_correlation_prop}:
\begin{equation}
\label{eq:correlation_set}
\correlationset_{\vec{\resolution},\vec{\channel}} =
    \setbuilder{\parens{\photon_{0},\photon_{1},\ldots\photon_{n-1}}}
               {\begin{aligned}
                \photon_{0}\in\photons_{\channel_{0}};\\
                \ldots;\\
                \abs{\braces{\photon_{0},\photon_{1},\ldots}} = n;\\
                \Time{\photon_{1}}-\Time{\photon_{0}}\in\resolution_{1};\\
                \ldots;
                \end{aligned}}
\end{equation}

And with that, we have defined all of the necessary sets to be calculated on the way to calculating the \nth-order correlation of photons. Note that these results are exact, with no approximations. For practical purposes we will introduce some approximations, but return to this result whenever those approximations fail.

%we must consider first what the normalization factor actually represents. In each discrete, finite-time correlation we restricted the limits of each time dimension to the values which could support a given time delay, that is, all $t$ under consideration for a given $\tau$ were chosen such that $t+\tau <N$. More generally:
%\begin{equation}
%t\in\setbuilder{t}{t+\tau\in\integrationtime}
%\end{equation}
%For higher dimensions, we must consider all possible time spans:
%\begin{equation}
%\label{eq:allowed_time_size}
%\integrationtime_{\vec{\tau}} = 
%     \setbuilder{t}{\begin{aligned}
%                   t+\tau_{1}\in\integrationtime; \\
%                   t+\tau_{2}\in\integrationtime; \\
%                   \ldots
%                   \end{aligned}}
%\end{equation}
%where $\integrationtime_{\vec{\tau}}$ represents the subset of times valid for the given time delays. On a practical note, it is straightforward to show the following:
%\begin{equation}
%\abs{\integrationtime_{\vec{\tau}}}
%   \equiv\abs{\setbuilder{t}{\begin{aligned}
%                   t+\tau_{1}\in\integrationtime; \\
%                   t+\tau_{2}\in\integrationtime; \\
%                   \ldots
%                   \end{aligned}}}
%   = \abs{\integrationtime} - \max{\braces{\abs{\tau_{1}},\ldots}}
%\end{equation}
%To simplify later results, we can define subsets of photons whose arrival times are in this subset of time:
%\begin{equation}
%\photons_{\integrationtime_{\vec{\tau}},\tau_{j}} 
%    \equiv \setbuilder{\photon} 
%                      {\begin{aligned}
%                       \photon\in\photons; \\
%                       \Time(\photon)+\tau_{j}\in\integrationtime_{\vec{\tau}}
%                       \end{aligned}}
%\end{equation}
%where $\tau_{j}$ is the $j$th index of $\vec{\tau}$. Omission of this value is equivalent to $\tau_{j}=0$. Additionally, denote the correlation set by:
%\begin{equation}
%G_{\vec{\tau}} 
%    \equiv \setbuilder{(\photon_{0},\ldots\photon_{n-1})}
%                         {\begin{aligned}
%                          \photon_{0}\in\photons;\\
%                          \ldots;\\
%                          \photon_{n-1}\in\photons;\\
%                          \abs{\braces{\photon_{0},\ldots\photon_{n-1}}}=n;\\
%                          \Time(\photon_{1})-\Time(\photon_{0})=\tau_{1};\\
%                          \ldots
%                          \end{aligned}}
%\end{equation}
%
%Given this result, we can assemble the full $n$th-order autocorrelation function:
%\begin{equation}
%\gn{n}(\tau_{1},\ldots\tau_{n-1}) = 
%   \frac{\abs{\integrationtime_{\vec{\tau}}}^{n-1}
%         \abs{G_{\vec{\tau}}}}
%        {\abs{\photons_{\integrationtime_{\vec{\tau}}}}
%         \prod_{j=1}^{n-1}
%               {\abs{\photons_{\integrationtime_{\vec{\tau}},\tau_{j}}}}}
%\end{equation}
%By addition of further conditions, we can write the result for an individual cross-correlation:
%\begin{equation}
%\gn{n}_{\vec{\channel}}(\tau_{1},\ldots\tau_{n-1}) = 
%   \frac{\abs{\integrationtime_{\vec{\tau}}}^{n-1}
%         \abs{\correlationset_{\vec{\tau},\vec{\channel}}}}
%        {\abs{\photons_{\integrationtime_{\vec{\tau}},\channel_{0}}}
%         \prod_{j=1}^{n-1}
%               {\abs{\photons_{\integrationtime_{\vec{\tau}},\channel_{j},\tau_{j}}}}}
%\end{equation}
%or express the autocorrelation as a sum over cross-correlation terms:
%\begin{equation}
%\gn{n}(\tau_{1},\ldots\tau_{n-1}) = 
%   \frac{\abs{\integrationtime_{\vec{\tau}}}^{n-1}
%         \sum_{\vec{\channel}\in\channels^{n}}
%         {\abs{G_{\vec{\tau},\vec{\channel}}}}}
%        {\abs{\photons_{\integrationtime_{\vec{\tau}}}}
%         \prod_{j=1}^{n-1}
%               {\abs{\photons_{\integrationtime_{\vec{\tau}},\tau_{j}}}}}
%\end{equation}
%
%As a final note, one important practical consideration is the fact that the time delays $\tau$ do not really represent single times but some range of times. This was implicit in the conversion from real to whole time and ultimately is just a rescaling of the time units, which is why we did not concern ourselves with it at the time. A more important consideration relates to choices of groupings of whole number time $\tau$, which is of importance for histogramming real data. To account for these windows $\resolution$, the correlation term must be normalized to account for the increased effective volume of phase space: in the current formula, the term measures the average number of correlation events per volume time space, and increasing the width of any dimension increases the volume of phase space. Thus the extra correction is found by dividing by the effective volume of phase space:
%\begin{equation}
%\label{eq:full_gn}
%\gn{n}(\resolution_{1},\ldots\resolution_{n-1}) = 
%   \parens{
%        \frac{\abs{\integrationtime_{\vec{\resolution}}}^{n-1}}
%             {\prod_{j=1}^{n-1}{\abs{\resolution_{j}}}}}
%   \parens{
%        \frac{\sum_{\vec{\channel}\in\channels^{n}}
%                   {\abs{\correlationset_{\vec{\tau},\vec{\channel}}}}}
%             {\abs{\photons_{\integrationtime_{\vec{\resolution}}}}
%              \prod_{j=1}^{n-1}
%                    {\abs{\photons_{\integrationtime_{\vec{\epsilon}},\resolution_{j}}}}}}
%\end{equation}
%This formula will be the basis of all further discussion, so if the definitions of its constituent terms are not clear you should work through this section again.

\subsubsection{Calculating \gn{n} for T3 data}
Equation~\ref{eq:gn_full} describes the formula for calculating the autocorrelation of a set of photons tagged with arrival channel and time. Extension of the result is a matter of introducing a second time vector $\vec{\rho}$ of pulse delays, and construction of sets with further restrictions $\Pulse(\photon_{j})-\Pulse(\photon_{0})=\rho$, where the function $\Pulse$ returns the pulse number of a photon. In many regards, this turns the \gn{n} function into one more akin to \gn{2n}, but with the restriction that $\tau_{j}$ and $\rho_{j}$ are associated with channel $\channel_{j}$.

\subsubsection{Calculating a single cross-correlation}
Following the logic of the preceding sections, if we wish to calculate a single cross-correlation for a given set of channels, we can use:
\begin{equation}
\label{eq:cross_correlation_full}
\gn{n}_{\vec{\channel}}\parens{\resolution}  = 
       \parens{\frac{\abs{\integrationtime}^{n}}
                    {\prod_{j=0}^{n-1}
                           {\abs{\photons_{
                                        \vec{\resolution},
                                        \resolution_{j},
                                        \channel_{j}}}}}}
      \parens{\frac{\abs{\correlationset_{\vec{\resolution},
                                          \vec{\channel},
                                          \channel}}}
                   {\prod_{j=1}^{n-1}{\abs{\resolution_{j}}}}}
\end{equation}
where the new $\channel$  subscripts indicate the addition of a $\Channel(\photon)=c$ condition to the set. Note that the cross-correlations cannot be added directly to recover the full autocorrelation, though knowledge of the normalization will enable such procedures.

\subsection{Subdividing the problem of calculating \gn{n}}
The efficient and accurate calculation of \gn{n} for a given set of photons \photons{} can be achieved by appropriate subdivision of the problem into its constituent terms. Each program described in this paper is designed to calculate some term in equation~\ref{eq:gn_full}:
\begin{itemize}
\item $\photons$: \picoquant, \intensity
\item $\integrationtime$: \intensity
\item $\resolution$: \GN
\item $\correlationset$: \correlate, \histogram
\end{itemize}
Each task is sufficiently specialized and independent of the others that the whole correlation process may be performed by piping the results of commands into each other. In each section, we will discuss the design principles and algorithms which make each step possible.

%The finite range of time affects the definition of an average by a scalar normalization factor, as implicitly included in equation~\ref{eq:sine_correlation}:
%\begin{equation}
%\angles{I(t)} = \frac{\int_{\integrationtime}{I(t)\,dt}}
%                     {\abs{\integrationtime}}
%\end{equation}
%weere $\int_{\integrationtime}$ is equivalent to $\int_{\tstop}^{\tstart}$ and $\abs{\integrationtime}=(\tstop-\tstart)$.. Consequently, each average in the autocorrelation picks up a factor of inverse integration time. The cross term is unfortunately not quite as simple to normalize:
%\begin{equation}
%\angles{I(t)I(t+\tau)} = \frac{\int_{\integrationtime\setminus[0,\tau)}{I(t)I(t+\tau)\,dt}}
%                              {\abs{\integrationtime\setminus[0,\tau)}}
%\end{equation}
%where $\setminus$ indicates the removal of some values from the set of times $\integrationtime$. 
%\begin{align}
%\gn{n}(\tau_{1},\ldots\tau_{n-1})
%  &= 
%     \frac{\abs{\integrationtime}^{-1}
%           \sum_{\vec{\channel}\in\channels^{n}}
%                {\brackets{
%                      \int_{\integrationtime}
%                           {\brackets{I_{\channel_{0}}(t)
%                                     \prod_{j=1}^{n-1}{I_{\channel_{j}}(t+\tau_{j})}}
%                            dt}}}}
%     {\abs{\integrationtime}^{-n}
%      \left(\sum_{\channel\in\channels}
%                 {\int_{\integrationtime}
%                       {I_{\channel}(t)\,dt}}\right)
%      \prod_{j=1}^{n-1}
%            \left({\sum_{\channel\in\channels}
%                        {\brackets{\int_{\integrationtime}
%                                        {I_{\channel}(t+\tau_{j})\,dt}}}}\right)} \\
%  &=      \frac{\abs{\integrationtime}^{n-1}
%           \sum_{\vec{\channel}\in\channels^{n}}
%                {\brackets{
%                      \int_{\integrationtime}
%                           {\brackets{I_{\channel_{0}}(t)
%                                     \prod_{j=1}^{n-1}{I_{\channel_{j}}(t+\tau_{j})}}
%                            dt}}}}
%     {\left(\sum_{\channel\in\channels}
%                 {\int_{\integrationtime}
%                       {I_{\channel}(t)\,dt}}\right)
%      \prod_{j=1}^{n-1}
%            \left({\sum_{\channel\in\channels}
%                        {\brackets{\int_{\integrationtime}
%                                        {I_{\channel}(t+\tau_{j})\,dt}}}}\right)} 
%\end{align}
%
%
%\subsection{Correlation of photons over discrete time steps}
%For physical reasons it is often convenient to sample the value of a signal at some fixed time interval. As such, the value of the signal is known for some values $\tstart,\tstart+\Delta t,\ldots$, which can be index as $0,1,\ldots$. Similarly, the set of times $\integrationtime$ ceases to represent a continuous range and instead becomes some finite subset of whole numbers. Formally, we now have:
%\begin{align}
%I:\wholes\rightarrow\reals^{*} \\
%\integrationtime \equiv \integers_{N}
%\end{align}
%where $\wholes$ is the set of whole numbers \braces{0,1,\ldots} and $N$ is the number of times sampled. One subtle but important consequence of mapping is that different experiments may carry different time steps, so we will define $\resolution$ as the resolution in a particular experiment. Substituting these results, we obtain the discrete correlation function:
%\begin{equation}
%\gn{n}(\tau_{1},\ldots\tau_{n-1}) = 
%     \frac{\abs{\integrationtime}^{n-1}
%           \sum_{\vec{\channel}\in\channels^{n}}
%                {\brackets{
%                      \sum_{t\in\integrationtime}
%                           {\brackets{\resolution_{c_{0}} I_{\channel_{0}}(t)
%                                      \prod_{j=1}^{n-1}{I_{\channel_{j}}(t+\tau_{j})}}}}}}
%     {\left(\sum_{\channel\in\channels}
%                 {\int_{\integrationtime}
%                       {I_{\channel}(t)\,dt}}\right)
%      \prod_{j=1}^{n-1}
%            \left({\sum_{\channel\in\channels}
%                        {\int_{\integrationtime}
%                              {I_{\channel}(t+\tau_{j})\,dt}}}\right)}
%\end{equation}

%\subsection{The true meaning of $I(t)$}
%\label{sec:sampling_intensity}
%For a real measurement, the signal $I(t)$ is real-valued and defined by averaging some signal for a time interval $\Delta t$, such that the value $I(t)$ really is
%\begin{equation}
%I(t) = \left.\angles{\iota(t')}\right|_{t'\in[t,t+\Delta t)} = \frac{1}{\Delta t}\int_{t}^{t+\Delta t}{\iota(t'),dt'}
%\end{equation}
%for the true function $\iota(t)$ being approximated by the measurement. As such, the $I(t)$ over time can be represented meaningfully as a vector representing the value of the function for evenly-spaced values of $t$, and the correlations can be determined as inner products of displacements of that vector. More concretely, consider a signal $\vec{I}\in\left(\reals^{*}\right)^{N}$ representing $N$ samples of $I(t)$ at $t=0, \Delta t, \ldots$, with elements indexed as $\vec{I}(0), \vec{I}(1),\ldots$. To calculate $\gn{2}(\tau)$ for $\tau\in\wholes$:
%\begin{equation}
%\gn{2}(\tau) = \frac{\sum_{j=0}^{N-\tau}{\vec{I}(j)\vec{I}(j+\tau)}}
%                    {\sum_{j=0}^{N-\tau}{\vec{I}(j)}\sum_{j=0}^{N-\tau}{\vec{I}(j+\tau)}}
%\end{equation}
%Note that, for $\tau\rightarrow N$, the number of elements in the sum approaches 0. This represents the undersampled region of the correlation, and as such it is necessary to define the correlation window as significantly smaller than the sampled window in order to obtain a meaningful estimate of $\gn{2}(\tau)$.
%
%This definition of a signal is useful for many measurements of some gross quantity which can be said to sample a non-trivial range of values in $\reals^{*}$ or \wholes. However, photon-counting produces a signal which is fundamentally binary (in $\integers_{2}$), indicating that either a photon has arrived in the time interval, or none has. In principle we can treat this vector in the same way as we do $\vec{I}$, but this is inefficient: there are only a few bins which will have any signal, and a great number which contain nothing. Therefore, for a binary signal which only occasionally has a non-zero value, it is worthwhile to develop different forms for the correlation expressed in equation~\ref{eq:gn}.
%
%\subsection{Defining the signal of photon arrivals}
%In practice, any given single-photon detector can detect exactly one photon at a time, such that any photon arrival can be defined unique by its detection channel and arrival time. Therefore, the photon $\gamma$ can be represented as a 2-tuple:
%\begin{equation}
%\photon\equiv (c, t)\in C\times\wholes
%\end{equation}
%We define the functions $\Channel(\photon)$ and $\Time(\photon)$ to return the channel and arrival time of a photon \photon. From this definition, call
%\begin{equation}
%\photons\equiv\braces{\photon}\subset C\times\wholes
%\end{equation}
%the set of all detected photons. This is the signal relevant to photon-correlation methods, and its form requires that we recast the correlation function in a way which is more directly applicable. 
%
%To begin with, the definition of the signal on a single channel can be expressed as:
%\begin{equation}
%\photons_{c} = \braces{\photon\left|\photon\in\photons;~\Channel(\photon)=c\right.}
%\end{equation}
%In long form, this signal is the set of all detected photons, restricted to those whose channels matches the channel specified (see appendix~\ref{sec:notation} for more details). Here, there is no longer an explicit time dependence, but we can define that with an additional parameter:
%\begin{equation}
%\photons_{c}(t) = \abs{\braces{\photon\left|\begin{aligned}
%                                          \photon\in\photons; \\
%                                           \Channel(\photon)=c;\\
%                                           \Time(\photon)=t
%                                     \end{aligned}\right.}}
%\end{equation}
%where here the \abs{\cdot} indicate the number of elements in the set. To recover the complete signal \photons:
%\begin{equation}
%\photons = \bigcup\limits_{c\in C}{\photons_{c}}
%\end{equation}
%
%\subsubsection{T3 mode is akin to T2 mode, but a second time dimension}
%As discussed in section~\ref{sec:modes}, T3 mode has a definition distinct from that of T2 mode:
%\begin{equation}
%\photon\equiv(c,p,t)\in C\times\wholes\times\wholes
%\end{equation}
%for which $\Pulse(\photon)$ returns the pulse number for which the photon arrived. While the definitions are not perfectly clean, we will show shortly how T3 photons can be treated exactly like a pair of T2 photons, with some restrictions.
%
%\subsection{Calculating \gn{n} by counting photons}
%As before, we will begin our discussion of correlation functions by constructing a set formulation of the autocorrelation. Fundamentally, we must consider two halves of a problem:
%\begin{equation}
%\gn{n}(\tau_{1},\ldots)=\frac{\textnormal{number of events which satisfy a given time delay}}
%     {\textnormal{average number of photons per unit of time}}
%\end{equation}
%The denominator is simpler to express, so we will start there. In a given experiment of finite length, there will be some absolute beginning and end of time, such that all detected photons are elements of the subset
%\begin{equation}
%\channels\times \wholes_{\integrationtime}
%\end{equation}
%for a total experiment time \integrationtime. That is, there exists some time $\integrationtime\in\wholes$ such that
%\begin{equation}
%\braces{\photon\left|\photon\in\photons;\Time(\photon)\ge\integrationtime\right.} = \emptyset
%\end{equation}
%Here, the integration time is defined such that there are \integrationtime{} time units which pass during the experiment, since time begins with 0. This sets the minimal value for \integrationtime{} to be one greater than the arrival time of the final photon in the experiment, or
%\begin{equation}
%\integrationtime\ge\max(\braces{\Time(\photon)|\photon\in\photons})
%\end{equation}
%Now that we have determined the total units of time represented by \photons{} (either by a defined value or by some maximal time \Time(\photon)+1), the average number of photons arriving per unit of time is
%\begin{equation}
%\angles{I(t)} = \frac{\abs{\photons}}{\integrationtime}
%\end{equation}
%Next, consider the set of photons satisfying some specified time delay $\tau$:
%\begin{equation}
%\angles{I(t)I(t+\tau)}\propto
%         \abs{\braces{(\photon_{0},\photon_{1})
%               \left|\begin{aligned}
%                     \photon_{0},\photon_{1}\in\photons;\\
%                     \Time(\photon_{1})-\Time(\photon_{0})=\tau
%                     \end{aligned}\right.}}
%\end{equation}
%This is accurate up to a normalization constant, which is related to the resolution of \Time. As discussed in section~\ref{sec:sampling_intensity}, the function does not have infinite resolution but instead approximates some true function by sampling for an interval we will call \resolution. As such, the set defined is actually for a square in time space with length \resolution{} ($t$ and $\tau$ are really $[t,t+\resolution)$ and $[\tau,\tau+\resolution)$), so we must correct for this value to be completely general:
%\begin{equation}
%\angles{I(t)I(t+\tau)}=    
%         \frac{1}{\resolution^{2}}
%         \abs{\braces{(\photon_{0},\photon_{1})
%               \left|\begin{aligned}
%                     \photon_{0},\photon_{1}\in\photons;\\
%                     \Time(\photon_{1})-\Time(\photon_{0})=\tau
%                     \end{aligned}\right.}}
%\end{equation}
%For the most precise form of this calculation, $\resolution=1$, but for practical reasons it will become necessary to undersample the correlation function by increasing the effective value of \resolution. This resolution should also be allowed to vary with $\tau$, so we will denote its full behavior $\resolution_{c}(\tau)$, where the $c$ subscript indicates its associated channel. Note that the reference channel $\channel_{0}$ does not have a varying resolution, because it has not associated time delay (see equation~\ref{eq:gn}). See section~\ref{sec:histogram} for more details.
%
%Putting this together, the full autocorrelation is
%\begin{equation}
%\gn{2}(\tau) = \frac{\integrationtime^{2}}{\abs{\photons}^{2}\resolution\resolution(\tau)}
%                \abs{\braces{(\photon_{0}, \photon_{1}),
%                              \left|\begin{aligned}
%                              \photon_{0},\photon_{1}\in\photons \\
%                              \Time(\photon_{1})-\Time(\photon_{0})=\tau
%                              \end{aligned}\right.}}
%\end{equation}
%Extension of this result to higher dimensions and multiple channels proceeds much as before, giving the following two-channel cross-correlation:
%\begin{equation}
%\gn{2}(\tau) = \sum\limits_{(c_{0},c_{1})\in C^{2}}
%                    {
%                    \frac{\integrationtime^{2}}
%                         {\abs{\photons_{c_{0}}}\abs{\photons_{c_{1}}}
%                                \resolution_{c_{0}}\resolution_{c_{1}}(\tau)}
%                    \abs{\braces{(\photon_{0},\photon_{1})
%                          \left|\begin{aligned}
%                          \photon_{0}\in\photons_{c_{0}};\\
%                          \photon_{1}\in\photons_{c_{1}};\\
%                          \Time(\photon_{1})-\Time(\photon_{0})=\tau
%                          \end{aligned}\right.}}
%                    }
%\end{equation}
%and this result for higher dimensions:
%\begin{equation}
%\label{eq:gn_set}
%\begin{split}
%&\gn{n}(\tau_{1},\ldots\tau_{n-1})= \\
%& \sum\limits_{\vec{c}\in C^{n}}
%                    {
%                    \left[
%                    \left(
%                    \frac{\integrationtime}{\abs{\photons_{c_{0}}}\resolution_{c_{0}}}
%                    \prod_{j=1}^{n-1}{\frac{\integrationtime}
%                                           {\abs{\photons_{c_{j}}}\resolution_{c_{j}}(\tau_{j})}}
%                    \right)
%                    \abs{\braces{(\photon_{0},\ldots\photon_{n-1})
%                          \left|\begin{aligned}
%                          \photon_{0}\in\photons_{c_{0}};\\
%                          \photon_{1}\in\photons_{c_{1}};\\
%                          \ldots;\\
%                          \Time(\photon_{1})-\Time(\photon_{0})=\tau_{1};\\
%                          \ldots
%                          \end{aligned}\right.}}
%                    \right]
%                    }
%\end{split}
%\end{equation}
%
%\subsubsection{The \gn{n} for T3 data can calculated like \gn{2n} for T2 data}
%Given the notation in equation~\ref{eq:gn_set}, we see that the two timing dimensions of T3 data can be treated as separate conditions in the set, with a second unit of resolution associated with \Pulse. Calling this unit of resolution $\kappa$ and the relative pulse difference $\rho$, the full expression is:
%\begin{equation}
%\label{eq:gn_set_t3}
%\begin{split}
%&\gn{n}(\tau_{1},\rho_{1},\ldots\tau_{n-1},\rho_{n-1}) = \\
%    &  \sum\limits_{\vec{c}\in \channels^{n}}
%                    {
%                    \left[
%                    \frac{\integrationtime^{2}}
%                         {\abs{\photons_{\channel_{0}}}\resolution_{\channel_{0}}\kappa_{\channel_{0}}}
%                    \left(
%                    \prod_{j=1}^{n-1}{\frac{\integrationtime^{2}}
%                                           {\abs{\photons_{c_{j}}}^{2}
%                                            \resolution_{c_{j}}(\tau_{j})
%                                            \kappa_{c_{j}}(\tau_{j})}}
%                    \right)
%                    \abs{\braces{(\photon_{0},\ldots\photon_{n-1})
%                          \left|\begin{split}
%                          \photon_{0}\in\photons_{c_{0}};\\
%                          \photon_{1}\in\photons_{c_{1}};\\
%                          \ldots;\\
%                          \Time(\photon_{1})-\Time(\photon_{0})=\tau_{1};\\
%                          \Pulse(\photon_{1})-\Pulse(\photon_{0})=\rho_{1};\\
%                          \ldots
%                          \end{split}\right.}}
%                    \right]
%                    }
%\end{split}
%\end{equation}
%This form is nearly identical to a \gn{2n} for T2 data, except that we still sample the channel combinations from $\channels^{n}$, reflecting the fact that $\tau_{j}$ and $\rho_{j}$ are associated with the same channel $\channel_{j}$. We will continue to discuss T2-type correlation functions, but do not that the machinery developed for such uses can easily be repurposed for T3 data.
%
%\subsection{Subdividing the problem of calculating \gn{n}}
%Examining equation~\ref{eq:gn_set}, it is evident that there are a few distinct factors associated with each term of the sum:
%\begin{itemize}
%\item $\integrationtime$: the integration time
%\item $\abs{\photons_{c}}$: the number of photons with a given channel \channel.
%\item $\resolution_{c}(\tau)$: the resolution of a channel at a given time delay
%\item $(\photon_{0},\ldots)$: $n$-tuples of photons with particular properties
%\end{itemize}
%Because these factors can be calculated or defined independently, we will turn our focus to the efficient determination of the value of each of these factors. Roughly, the terms can be calculated using the following programs:
%\begin{itemize}
%\item $\integrationtime$: \intensity
%\item $\abs{\photons_{c}}$: \intensity
%\item $\resolution_{c}(\tau)$: \picoquant, \histogram
%\item $(\photon_{0},\ldots)$: \correlate, \histogram
%\end{itemize}
%The remainder of this paper is devoted to specifying how each term may be calculated efficiently and accurately.

%In principle it is possible to bin these photon arrivals to count the number of arrivals in some time interval and recover the vector-like signal discussed above, but such steps introduce a range of subtle artifacts related to the precise origin of time and definition of bin resolution. These problems are largely avoidable if we instead develop a definition of \gn{n} which involves counting these events directly.

%Do note, however, that the ``true'' photon arrival time discussed from here on is itself a binary form of this vectorial definition, because real instruments will have some finite timing resolution. In this sense, the idea of a discrete arrival time is just a simplification of the true signal, where each sampling represents the state of a photon arriving or not arriving during that interval. Many more samples will find no photon than one, so those are simply not reported. Additionally, this means that the reported photon arrival time carries some time units defined by the resolution of the measurement, so we can declare any arrival time $t$ to be a multiple of these time steps, or $t\in\wholes$, where \wholes{} is the set of all whole numbers (the positive integers and zero).  
%Figure~\ref{fig:gaussian_g2} shows this result for various values of the four adjustable parameters, demonstrating the symmetric and asymmetric behavior of the various terms in the sum.
%
%\begin{figure}
%\centering
%\caption{Graphs showing different \gn{2} for a sum of two Gaussians as parameters are tuned.}
%\label{fig:gaussian_g2}
%\end{figure}

% A correlation of such a signal quantifies the randomness of its behavior over time: a signal with strong time correlation has well-defined behavior at a time $I(t+\tau)$ given a value at $I(t)$, and weaker correlation indicates that the value is less well-defined, approaching complete randomness. The correlation of a signal with itself (its autocorrelation) can be defined as:
%\begin{equation}
%\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
%                    {\angles{I(t)}\angles{I(t+\tau)}}
%\end{equation}
%where the angled brackets indicate an average over $t$. For this function, a value $\gn{2}(\tau)=1$ indicates non-correlation: at a time delay $\tau$, the value $I(t+\tau)$ is on average the same as $I(t)$. For $\gn{2}(\tau)>1$, $I(t+\tau)$ is greater than $I(t)$, and for $\gn{2}(\tau)<1$, $I(t+\tau)$ is less than $I(t)$. In terms of photon correlation methods, $\gn{2}(\tau)>1$ is called super-bunching (a photon arrival is likely to be followed by another), while $\gn{2}(\tau)<1$ is called anti-bunching (a photon arrival is likely to be followed by a lack of photons).
%
%For example, consider the autocorrelation of a sinusoid:
%\begin{align}
%\gn{2}(\tau) &= \frac{\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\left(1+\sin{(t+\tau)}\right)\,dt}}
%                     {\left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t)}\right)\,dt}\right)
%                      \left(\frac{1}{2\pi}\int_{-\pi}^{\pi}{\left(1+\sin{(t+\tau)}\right)\,dt}\right)} \\
%             &= 1 + \frac{1}{2}\cos{(\tau)}
%\end{align}
%it is evident that there is some structure to the autocorrelation, such that there is some probability of the signal being stronger or weaker at relative time delays $\tau$. 
%
%As an example which is more relevant to photon-correlation, consider a pulse train represented by
%\begin{equation}
%\label{eq:delta_train}
%I(t) = \sum_{n\in\integers}{\delta(t-n)}
%\end{equation}
%where $\delta$ here represents the mathematical delta function
%\begin{equation}
%\delta(t) = \left\lbrace \begin{split}
%                          1;~t=0 \\
%                          0;~t\not=0
%                         \end{split}
%            \right.
%\end{equation}
%This signal represents is a regularly-spaced pulse train where a single pulse arrives every unit of time, and as such its autocorrelation is:
%\begin{equation}
%\gn{2}(\tau) = \sum_{n\in\integers}{\delta(\tau-n)}
%\end{equation}
%
%
%\subsection{Extending the correlation arbitrary numbers of signals}
%While the autocorrelation of a signal is often a meaningful quantity to calculate, cross-correlations are more general and have many more applications. For example, the cross-correlation of a laser pulse train and the response of a light-emitting sample can be used to measure the lifetime of the emissive state, and is the implicit measurement of the interactive mode. 
%
%Generalization of the correlation is fairly simple: the numerator holds an average over a product of some number of signals with time delays relative to a reference channel, normalized by the average intensity at each channel. For two channels, this can be expressed as:
%\begin{equation}
%\label{eq:g2}
%\gn{2}(\tau) = \frac{\angles{I_{0}(t)I_{1}(t+\tau)}}
%                    {\angles{I_{0}(t)}\angles{I_{1}(t+\tau)}}
%\end{equation}
%Generalization to higher dimensions is relatively straightforward:
%\begin{equation}
%\label{eq:gn}
%\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
%	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
%	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
%\end{equation}
%where the $\prod$ notation indicates a product of elements, akin to the $\sum$ notation for summation.

%\subsubsection{Mapping T3 correlations onto T2-like correlations}
%One benefit of generalizing the correlation to higher dimensions is that it provides a simple way to treat correlations of T3 data as higher-dimensional T2 data. For example, if we apply the map
%\begin{equation}
%\left(c_{j}, p_{j}, t_{j}\right) \rightarrow \left(\left(c_{j}, p_{j}\right), \left(c_{j}, t_{j}\right)\right)
%\end{equation}
%it is evident that we can treat the single T3 entry as containing two dimensions of time to analyze independently. Therefore, any calculation of a correlation of T3 data can be expressed as
%\begin{equation}
%\gn{n}(\rho_{1}, \tau_{1}, \ldots \rho_{n-1}, \tau_{n-1}) = \frac
%	{\angles{I_{0}(p, t)\prod_{j=1}^{n-1}{I_{j}(p+\rho_{j},t)I_{j}(p,t+\tau_{j})}}}
%	{\angles{I_{0}(p, t)}^{2}\prod_{j=1}^{n-1}{\angles{I_{j}(p+\rho_{j},t)}
%	                                       \angles{I_{j}(p,t+\tau_{j})}}}
%\end{equation}
%For the rest of this paper, T3 data will be treated as higher-dimensional T2 data.
%
%\subsection{The true meaning of $I(t)$}
%For many measurements, the signals $I_{j}(t)$ are real-valued and defined by averaging some signal for a time interval $\Delta t$, such that the value $I_{j}(t)$ really is
%\begin{equation}
%I_{j}(t) = \left.\angles{\iota_{j}(t')}\right|_{t'\in[t,t+\Delta t)} = \frac{1}{\Delta t}\int_{t}^{t+\Delta t}{\iota_{j}(t'),dt'}
%\end{equation}
%for a the true function $\iota(t)$. As such, the $I(t)$ over time can be represented meaningfully as a vector representing the value of the function for evenly-spaced values of $t$, and the correlations can be determined as inner products of displacements of that vector. More concretely, consider a signal $\vec{I}\in\reals^{N}$ representing $N$ samples of $I(t)$ at $t=0, \Delta t, \ldots$, with elements indexed as $\vec{I}(0), \vec{I}(1),\ldots$. To calculate $\gn{2}(\tau)$ for $\tau\in\integers^{*}$:
%\begin{equation}
%\gn{2}(\tau) = \frac{\sum_{j=0}^{N-\tau}{\vec{I}(j)\vec{I}(j+\tau)}}
%                    {\sum_{j=0}^{N-\tau}{\vec{I}(j)}\sum_{j=0}^{N-\tau}{\vec{I}(j+\tau)}}
%\end{equation}
%Note that, for $\tau\rightarrow N$, the number of elements in the sum approaches 0. This represents the undersampled region of the correlation, and as such it is necessary to define the correlation window as significantly smaller than the sampled window in order to obtain a meaningful estimate of \gn{n}.
%
%This definition of a signal is useful for many measurements of some gross quantity which can be said to sample a non-trivial range of values in \reals{} or \integers. However, photon-counting produces a signal which is fundamentally binary (in $\integers_{2}$), indicating that either a photon has arrived, or none has. In principle it is possible to bin these photon arrivals to count the number of arrivals in some time interval and recover the vector-like signal discussed above, but such steps introduce a range of subtle artifacts related to the precise origin of time and definition of bin resolution. These problems are largely avoidable if we instead develop a definition of \gn{n} which involves counting these events directly.
%
%Do note, however, that the ``true'' photon arrival time discussed from here on is itself a binary form of this vectorial definition, because real instruments will have some finite timing resolution. In this sense, the idea of a discrete arrival time is just a simplification of the true signal, where each sampling represents the state of a photon arriving or not arriving during that interval. Many more samples will find no photon than one, so those are simply not reported. Additionally, this means that the reported photon arrival time carries some time units defined by the resolution of the measurement, so we can declare any arrival time $t$ to be a multiple of these time steps, or $t\in\wholes$, where \wholes{} is the set of all whole numbers (the positive integers and zero).  
%
%\subsection{Calculating \gn{n} by counting photons}
%As in equation~\ref{eq:delta_train}, it is possible to define the signal representing arrivals of photons as a sum over a set of $\delta$-functions. Consider the set $T\subset\wholes$ of photon arrival times. The signal can be defined as
%\begin{equation}
%I(t) = \sum_{t'\in T}{\delta(t-t')}
%\end{equation}
%This notation is cumbersome, so from here we will refer to a photon arrival time as $t'$ alone, but the $\delta$ notation could be substituted as desired. This change makes the summation notation difficult to parse, so we instead switch to a set notation:
%\begin{equation}
%I(t) = \abs{\braces{\left. t'\right|t'\in T;~t-t'=0}}
%\end{equation}
%In long form, this definition counts the number of photon arrival times $t'$ which are equal to the requested time $t$. This is computationally inefficient but conceptually simple, so we will define all important quantities in this fashion before discussing how to compute the result efficiently.
%
%Extending this notation to \gn{2} for a single signal:
%\begin{equation}
%\gn{2}(\tau) = \frac{\abs{\braces{(t_{j}, t_{k})\left|
%                          \begin{split} 
%                            t_{j}, t_{k}\in T; \\
%                            t_{j}-t_{k}=\tau
%                          \end{split}\right.
%                    }}}
%                    {\abs{\braces{T}}^{2}/\left(max(T)-min(T)\right)^{2}}
%\end{equation}
%where $min$ and $max$ are the functions which return the minimum and maximum values of a set, respectively. Even this definition is not quite sufficient: the measurement carries its own unit of time $\resolution$, which means that any time $t$ specified is really a range $[t,t+\resolution)$, so with appropriate normalization the result becomes:
%\begin{equation}
%\gn{2}(\tau) = \frac{\abs{\braces{(t_{j}, t_{k})\left|
%                          \begin{split} 
%                            t_{j}, t_{k}\in T \\
%                            t_{j}-t_{k}=\tau
%                          \end{split}\right.
%                    }}}
%                    {\resolution^{2}\abs{\braces{T}}^{2}/\left(max(T)-t\right)^{2}}
%\end{equation}
%This result is identical to the normalization of histogrammed values, which will be discussed later.
%
%Extending this result to a number of signals, we obtain
%\begin{equation}
%\label{eq:gn_set}
%\gn{n}(\tau_{1}, \ldots) = \frac{\abs{\braces{(t_{0}, t_{1}, \ldots)\left|
%                                      \begin{split}
%                                      t_{0}\in T_{0}; t_{1}\in T_{1};\ldots \\
%                                      t_{1}-t_{0} = \tau_{1}; \ldots
%                                      \end{split}\right.}}}
%                                {\prod_{j=0}^{n-1}{\resolution_{j}\frac{\abs{T_{j}}}{max(T_{j})-min(T_{j})}}}
%\end{equation}
%Typically, the signals being correlated will come from the same device, such that all $\resolution_{j}$ are equal, leading to the final formula:
%\begin{equation}
%\label{eq:gn_set}
%\gn{n}(\tau_{1}, \ldots) = \frac{\abs{\braces{(t_{0}, t_{1}, \ldots)\left|
%                                      \begin{split}
%                                      t_{0}\in T_{0}; t_{1}\in T_{1};\ldots \\
%                                      t_{1}-t_{0} = \tau_{1}; \ldots
%                                      \end{split}\right.}}}
%                                {\prod_{j=0}^{n-1}{\resolution\frac{\abs{T_{j}}}{max(T_{j})-min(T_{j})}}}
%\end{equation}
%
%\subsection{Subdividing the problem of calculating \gn{n}}
%The expression in equation~\ref{eq:gn_set} is somewhat intimidating, but we can divide its 

\section{Picoquant}
\subsection{Purpose}
This program decodes binary data from the Picoquant hardware and outputs the data in human-readable format. Currently, \picoquant{} supports most modes and versions of the Timeharp, Picoharp, and Hydraharp. The board and mode are detected automatically, and if the mode is not supported an error message will explain the details.

Modes and software versions supported:
\begin{itemize}
\item Timeharp: v20 (thd), v30 (thd, t3r), v50 (thd), v60 (thd, t3r)
\item Picoharp: v20 (phd, pt2, pt3)
\item Hydraharp: v10 (hhd, ht2, ht3)
\end{itemize}

\subsection{Command-line syntax}

\begin{verbatim}
Usage: picoquant [options]

Version 1.1

                -h, --help: Prints this usage message.
             -v, --verbose: Print debug-level information.
             -i, --file-in: Input filename. By default, this 
                             is stdin.
            -o, --file-out: Output filename. By default, this is stdout.
           -a, --binary-in: Specifies that the input file is in binary format,
                            rather than text.
          -b, --binary-out: Specifies that the output file is in binary format,
                            rather than text.
              -n, --number: The number of entries to process. By default, 
                            all entries are processed.
         -p, --print-every: Print a status message every n entries.
                            By default, nothing is printed.
         -r, --header-only: Rather than processing any data, print the header
                            of the file in an ini-like format. This is useful
                            for debugging and verifying file settings.
     -z, --resolution-only: Rather than processing any data, print the 
                            resolution of the measurement. For TTTR modes, 
                            this is a single float, but for interactive data
                            the resolution of each curve is given.
               -t, --to-t2: For t3 data, use the sync rate to determine the
                            time represented by the sync count and output the
                            data in t2 mode. Note that this will only be
                            reasonable if the sync source is perfectly regular.

This program decodes data collected using Picoquant hardware. 
The binary data is decoded to detect the hardware version and
collection mode, and the data are output in a mode-specific
ascii format.
\end{verbatim}

\subsubsection{Input}
The input is either binary stream of data from the timing hardware, or the name of a file containing that data. The details of each format are too varied and verbose to be summarized here, but are laid out in detail in section~\ref{sec:formats}.

\subsubsection{Output}
\label{sec:picoquant_output}
The output will either be written to \stdout{} or the file specified. By default, the stream will be represented as ascii text, but use of the \texttt{--binary-out} flag will skip the formatted print in favor of a raw binary stream. 

All records are processed in the order they are found in the data stream. This is typically time-ordered.

\paragraph{Interactive}
Each record is of the form:
\begin{verbatim}
struct {
    unsigned int curve;
    double left_edge;
    double right_edge;
    unsigned int counts;
};
\end{verbatim}
printed as:
\begin{verbatim}
curve number, left edge of time bin, right edge of bin, counts \n
\end{verbatim}

\paragraph{T2}
Each record is of the form:
\begin{verbatim}
struct {
    unsigned int channel;
    long long int time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, time \n
\end{verbatim}

\paragraph{T3}
Each record is of the form:
\begin{verbatim}
struct {
	unsigned int channel;
	long long int pulse_number;
	int time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, pulse number, time \n
\end{verbatim}
	
\subsection{Examples of usage}
\subsubsection{Reading header information}
\begin{verbatim}
> picoquant --file-in data.phd --header-only
Ident = PicoHarp 300
FormatVersion = 2.0
CreatorName = PicoHarp Software
CreatorVersion = 2.3.0.0
FileTime = 14/05/11 17:55:48
Comment = Untitled
NumberOfCurves = 8
   ....
\end{verbatim}

Reading these values is often a good way to check the integrity of a file, and to make sure that the correct settings are used in later processing. The keywords used here are consistent with those used in the documentation for the file type as provided by Picoquant, so common values like measurement resolution may not be identical across versions and boards. 

\subsubsection{Obtaining the resolution of a measurement}
Resolution values must be multiples of 1\pico\second{} for most of the devices, but for the Timeharp they are integer divisions of 1\nano\second, leading to non-integer multiples of 1\pico\second. As such, all resolution values are presented as floats, even those which could be written as integers.
\begin{verbatim}
> picoquant --file-in data.phd --resolution-only
0,1.280000e+02
1,1.280000e+02
2,1.280000e+02
3,1.280000e+02
4,1.280000e+02
5,5.120000e+02
6,1.280000e+02
\end{verbatim}
Interactive mode allows for a large number of curves, so the resolution report gives the resolution for each curve, by index.
\begin{verbatim}
> picoquant --file-in data.pt2 --resolution-only
1.280000e+02
\end{verbatim}

\subsubsection{Reading interactive data}
\begin{verbatim}
> picoquant --file-in data.phd
0,0.000,0
...
3,4.482,4.484,2620
3,4.484,4.486,2595
3,4.486,4.488,2601
3,4.488,4.490,2604
3,4.490,4.492,2447
3,4.492,4.494,2407
3,4.494,4.496,2418
...
\end{verbatim}

\subsection{Reading T2/T3 data}
\begin{verbatim}
> picoquant --file-in data.pt2
0,7128264
0,20957636
0,33684532
0,36576452
0,42146280
0,42251400
0,65787700
0,75149552
0,86537580
0,109288316
> picoquant --file-in data.pt3
1,103,47360
1,109,47616
1,115,85760
1,115,248832
1,213,55552
1,245,244992
1,254,49920
1,267,69888
1,268,122368
1,274,58624
\end{verbatim}

\subsection{Translating T3 data to T2 data}
\begin{verbatim}
> picoquant --file-in data.pt3 --to-t2
1,41248184
1,43648488
1,46086680
1,46249752
1,85257256
1,98246952
1,101651952
1,106872024
1,107324512
1,109660816
\end{verbatim}

\subsection{Mode- and hardware-specific information}
\label{sec:formats}

While there are many differences between the formats of the files generated by the different boards and modes, they all follow a common structure:
\begin{itemize}
\item a general header identifying the board type and software version
\item a board-specific header, identifying hardware and software configuration
\item a mode-specific header
\item data
\end{itemize}

As such, the process of streaming data can be broken down into the following steps:
\begin{enumerate}
\item Identify the board type (\texttt{picoquant.c})
\item Identify the software version used to generate the file (\texttt{hydraharp.c}, \texttt{picoharp.c}, \texttt{timeharp.c}).
\item Determine the collection mode used (\texttt{hydraharp/hh\_*.c}, $\ldots$).
\item  \begin{enumerate}
  \item If the run is specified as resolution-only or header-only, print the appropriate values.
  \item Otherwise, read through the remaining header information and print the data.
  \end{enumerate}
\end{enumerate}

In this implementation, while the code used to produce the data and headers is very similar between software versions for a given board, there are some small differences which make a general program difficult to write. As such, each version is hard-coded, and any changes to the overall structure of the program must be rolled out to all versions. Fortunately, many common tasks such as printing of data are centralized in \texttt{picoquant.c}, so changes to the output format only require modification of a single function.

In principle, the code can be collected into a nicer data-streaming object which masks the translation process and yields only the resulting data stream. This is probably the most convenient way to deal directly with developing custom tools for data processing, but for most purposes passing the data through pipes should be sufficient. If such an interface is desired, the low-level translation functions (found in \texttt{*/*\_v*.c}) should be sufficient when wrapped with higher-level logical routines like those used to determine the board identity and version. The function structure is uniform across all versions and boards, which should simplify the wrapping process.

The remainder of this section is devoted to a discussion of the details important to each board and measurement type. Most of this information can be found in the manuals included with the hardware, but there is a significant amount of information which is documented in more scattered locations, such as the sample data code. This summary includes the details vital to understanding how the raw data are actually translated into the general data streams, and how various design decisions affect the quality and precision of the result.

\subsubsection{A word about external markers}
Many of the timing boards have a feature which allows the insertion of an external timing pulse into the signal, for use in TTTR modes to designate a raster scan or other time-dependent behavior. These records are not handled directly by \picoquant, but instead a message is passed to \stderr{} indicating that such a record exists. If different behavior is desired (perhaps assignment of the marker to a non-existent channel), modify the function \texttt{external\_marker} in \texttt{picoquant.c}. This will cause problems with the other programs, which assume every record originates from the true signal stream, so such an alteration must be accompanied by code which appropriately splices the signal stream, for example by halting collection into a histogram and initiation of a new one.

\subsubsection{T3 timing carries units of histogram bins, not time}
In T3 modes--including T3R for the Timeharp--the pulse dimension carries units of pulse number, but the time is not strictly a time with fixed units. Instead, the specified resolution of the interactive mode is the unit of time, such that the measurement is affected directly by this choice of resolution. As a result, the T3 record more directly reflects the index of the bin the record would have fallen into in interactive mode. In \picoquant{} this value is converted to units of \pico\second{} implicitly, but do be aware of this distinction.

\subsubsection{Translation of T3 to T2 data}
In principle, if the sync source of a T3-mode experiment arrives with perfectly uniform spacing, the pulse number can be said to represent some constant amount of time, and a T2-like record recovered. To do this, pass the flag \texttt{--to-t2} for an input of T3 data, but consider the implications of how this translation is performed (see section~\ref{sec:t3_to_t2}). 

In \picoquant, the average rate of sync pulses is used to determine the time unit a pulse carries.

%For a frequency $f$ of the arrival of a sync source, pulse number $p$ and time delay $t$ on channel $c$ map as:
%\begin{equation}
%\left(c, p_{j}, t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}}{f} + t_{j}\right)
%\end{equation}
%In practice, this mapping is limited in precision in a few important ways. First, the period $1/f$ is not necessarily an integer multiple of 1\pico\second, and any precision will be lost beyond the decimal. This is not usually a problem because typical sync sources operate at 10\mega\hertz{} at most, for a precision of timing to one part in ten thousand, and a purity of the pulse train to this precision is not typical. Additionally, the timing jitter of most lasers will be well above this threshold, so this is not too great a concern.
%
%A more important concern is that of missed pulses. The T3 data reports the detected pulse number, and if a sync pulse is missed no record will exist. However, translation of any subsequent record to an absolute time will be incorrect by the period $1/f$, confusing matters where such spacing is important. Again, a well-designed system should not have problems beating this limit, but it is the greatest single source of error during the translation.
%
%Collectively, these errors can be expressed as:
%\begin{equation}
%\left(c_{j}, p_{j}+\delta p_{j}, t_{j} + \delta t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}+\delta p_{j}}{f+\delta f} + \left(t_{j}+\delta t_{j}\right)\right)
%\end{equation}

\subsubsection{Timeharp}
The Timeharp is the least sophisticated of the three boards discussed here, and is fundamentally a histogramming board. It features two input channels, and its three modes are:
\begin{itemize}
\item interactive (thd): Collection of a histogram, using channel 0 as the sync and channel 1 as the signal.
\item continuous interactive (thc): Identical to normal interactive mode, except that the histogram is reported at the end of a user-specified time interval, repeating until halted. This feature is used for experiments requiring time resolution of a time-dependent feature, such as a fluctuating fluorescence lifetime. This feature is not supported by the existing software, due to lack of data or interest in using this mode (it is not present in the other timing boards).
\item time-tagged time-resolved (t3r): TTTR mode, equivalent to T3 mode, with channel 0 as the sync and channel 1 as the signal. Instead of reporting the delay time directly, this mode reports the index of the histogram bin an event would fall into. The time delay represented by the delay can be recovered from the header information, but for homogeneity of the treatment of T3-like data this step is not performed automatically.
\end{itemize}

\subsubsection{Picoharp}
The Picoharp features two input channels. Its three modes are:
\begin{itemize}
\item interactive (phd): Standard interactive mode, using channel 0 as the sync and channel 1 as the signal.
\item t2 (pt2): A T2 mode, with both channels treated equally and all pulse arrivals recorded. 
\item t3 (pt3): A T3 mdoe, with channel 0 as the sync and channel 1 as the signal.
\end{itemize}
In both the T2 and T3 mode, internal clocks of limited precision ($<$32 bits) are used to record the passage of time or pulses. As such, many records are devoted to recording the occurrence of an integer overflow. These records are treated by \picoquant{} automatically, producing data streams of the form specified in section~\ref{sec:picoquant_output}.

\subsubsection{Hydraharp}
The Hydraharp features a dedicated sync channel and four input channels. Its three modes are:
\begin{itemize}
\item interactive (hhd): Standard interactive mode, with four separate histograms assigned to  the four input channels.
\item t2 (ht2): A T2 mode, with all channels treated equally, including the sync channel. If the sync channel is active, these events will be recorded, and for convenience \picoquant{} will output each event as arriving on channel 4. This channel index can be altered by modifying value of the global variable \texttt{HH\_SYNC\_CHANNEL} (\texttt{hydraharp.h}) at compilation time. 
\item t3 (ht3): A standard t3 mode.
\end{itemize}
Future versions of the Hydraharp are being developed with extra input channels. If your model features extra channels, it should be sufficient to modify the value of \texttt{HH\_SYNC\_CHANNEL}, as the number of channels and modules is handled dynamically by \picoquant.

\section{Intensity}
\subsection{Purpose}
For T2 and T3 data, it is often useful to group records into fixed time bins and count the number of records in each bin. This program does just that, reporting the intensity at each channel for all data in a time-ordered stream. 

\subsection{Command-line syntax}
\begin{verbatim}
Usage: intensity [-v] [-i file_in] [-o file_out] [-c channels]
                 -w bin_width -m mode

           -v, --verbose: Print debug-level information.
           -i, --file-in: Input file. By default, this is
                          STDIN.
          -o, --file-out: Output file. By default, this is
                          STDOUT.
         -w, --bin-width: Width of the bin, in time or pulses
                          depending on the mode.
              -m, --mode: Stream type. This is either t2 or t3,
                          and the style of the output will be
                          different for each.
          -c, --channels: Number of channels in the stream. By
                          default, this is 2.
         -a, --count-all: Rather than counting records in 
                          distinct time bins, count all records 
                          in the stream.
              -h, --help: Print this message.

       This program assumes the input stream is time-ordered.
       
       If counting all events or printing the last one, the time
       written will be the time of the last event seen.
\end{verbatim}

\subsubsection{Input}
T2 and T3 modes accept data of the form produced by \picoquant, as specified in section~\ref{sec:picoquant_output}.

\subsubsection{Output}
The output for both T2 and T3 modes is of the form:
\begin{verbatim}
lower time limit, upper time limit, 
  channel 0 intensity, channel 1 intensity, ... \n
\end{verbatim}
For T2 mode, the time bin is defined as a number of picoseconds. For T3 mode, the time bin is a number of pulses.

Passing the flag \texttt{--count-all} will ignore the time bins, and instead count all events on each channel as belonging to one large channel. 

\subsection{Examples of usage}
Count into 10\milli\second{} bins.
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 
0,10000000000,555,0
10000000000,20000000000,524,0
20000000000,30000000000,564,0
30000000000,40000000000,536,0
40000000000,50000000000,495,0
50000000000,60000000000,530,0
60000000000,70000000000,514,0
70000000000,80000000000,548,0
80000000000,90000000000,558,0
90000000000,100000000000,565,0
100000000000,110000000000,550,0
110000000000,120000000000,490,0
120000000000,130000000000,559,0
130000000000,140000000000,504,0
140000000000,150000000000,547,0
150000000000,160000000000,537,0
160000000000,170000000000,535,0
170000000000,180000000000,545,0
180000000000,186537236212,344,0
\end{verbatim}
Count all events:
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 \
  --count-all
0,186537236212,10000,0
\end{verbatim}

\subsection{Implementation details}
\label{sec:intensity_implementation}
Each channel can be treated independently, so we can focus on how to handle a single stream of records. 

Given a set of photons $\photon\in\photons$, our goal is to determine the number of $\photon$ whose arrival times are in a time range $\epsilon$:
\begin{equation}
I(\resolution) = \abs{\setbuilder{\photon}{\photon\in\photons;~\Time(\photon)\in\epsilon}}
\end{equation}
In our case, we will only be concerned with time intervals $\resolution$ which are consecutive and collectively span the full integration time:
\begin{align}
\resolution_{j} &= \left[[\resolution_{j}\upminus,\resolution_{j+1}\upplus\right) \\
\integrationtime &= \bigcup\limits_{j=0}^{m}{\resolution_{j}}
\end{align}
As such, any photon can belong to exactly one subset $\photons_{\resolution_{j}}$, and these $\resolution_{j}$ can each be visited exactly once by iterating through times in the experiment. This can be performed efficiently if we impose the condition that the stream of photons be time-ordered, by iterating over photons and bins alternately:
\lstset{language=Python}
\begin{lstlisting}
photon = next(photons)
time_bin = next(time_bins)
intensity = 0

while photon and time_bin:
    if photon in time_bin:
        intensity += 1
        photon = next(photon)
    else:
        yield(time_bin, intensity)
        time_bin = next(time_bins)
        intensity = 0

yield(time_bin, intensity)
\end{lstlisting}
As can be seen, this algorithm scales linearly with the number of time bins and photons, i.e. it scales as O(\abs{\photons}). This algorithm requires time-ordered photons and bins which never lag behind the photon stream, which are guaranteed by appropriate initialization of the photon and bin streams.

\section{Correlate}
\label{sec:correlate}
The details of the mathematics required for understanding this program can be found in section~\ref{sec:math_background}. If you have not read that section, the discussion of the implementation here may be difficult to follow, but a brief explanation of the background will be given at each step.
%\subsection{A brief mathematical background}
%\label{sec:correlate_math}
%For several types of experiments, some form of a signal correlation is necessary. These follow the form:
%\begin{equation}
%\label{eq:correlation}
%\gn{n}(\tau_{1}, \ldots \tau_{n-1}) = \frac
%	{\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}}
%	{\angles{I_{0}(t)}\prod_{j=1}^{n-1}{\angles{I_{j}(t+\tau_{j})}}}
%\end{equation}
%where $I_{j}(t)$ are the intensities of some number of signals and the angled brackets indicate an average over time. For some purposes, the autocorrelation of a signal is of interest, where all $I_{j}(t)$ are identical, but in other cases some mixture of signals is of interest, and not necessarily in numerical order. For example, fluoroescence correlation spectroscopy requires the calculation of a second-order autocorrelation of fluorescence intensity, or:
%\begin{equation}
%\label{eq:g2}
%\gn{2}(\tau) = \frac{\angles{I(t)I(t+\tau)}}
%                 {\angles{(I(t)}\angles{(I(t+\tau)}}
%             = \frac{\angles{I(t)I(t+\tau)}}
%                 {\angles{(I(t)}^{2}}
%\end{equation}
%where $I(t)$ includes signal across all detection channels. In most cases, calculation of \gn{2} is sufficient, but in this definition we have implicitly limited our discussion to T2-like signals, with one independent variable per signal. In the case of T3-mode signals, we really have two independent variables: pulse number and arrival time. In principle, we could write something like
%\begin{equation}
%\gn{n}(\rho_{1}, \tau_{1}, \ldots \rho_{n-1}, \tau_{n-1}) = \frac
%	{\angles{I_{0}(p, t)\prod_{j=1}^{n-1}{I_{j}(p+\rho_{j},t)I_{j}(p,t+\tau_{j})}}}
%	{\angles{I_{0}(p, t)}^{2}\prod_{j=1}^{n-1}{\angles{I_{j}(p+\rho_{j},t)}
%	                                       \angles{I_{j}(p,t+\tau_{j})}}}
%\end{equation}
%where the average is now over all pulse and real time. However, because both pulse and real time are integer spaces, we can just map the times onto two homogeneous dimensions, and perform the correlation \gn{2n} instead. This gives a \gn{n} for every choice of pulses, useful for comparisons of long- and short-time correlations, as in multi-excition spectroscopy.

\subsection{Purpose}
This program calculates the full correlation of a signal, including all autocorrelations and cross-correlations of individual channels, for arbitrary numbers of channels and order. The raw correlation events are returned as the output, \textit{not the histogrammed correlation}. The histogramming and normalization are left for other programs, such as \texttt{histogram}.

The speed of the calculation scales favorably with the order of correlation, although of course higher orders of correlation require greater numbers of events to build meaningful results. See section~\ref{sec:correlation_implementation} for details of the algorithm.

\subsection{Command-line syntax}
\begin{verbatim}
Usage: correlate [-v] [-i file_in] [-o file_out] [-a] [-b] 
                 [-n number] [-p print_every] [-q queue_size]
                 [-d max_time_distance] [-e max_pulse_distance]
                 [-r] -g order -c channels -m mode

           -v, --verbose: Print debug-level information.
           -i, --file-in: Input file. By default, this is 
                          STDIN.
          -o, --file-out: Output file. By default, this is 
                          STDOUT.
       -p, --print-every: Print the result for multiples of 
                          this number of entries. Default is to
                          print nothing.
              -m, --mode: Stream type. This is either t2 or t3,
                          and the style of the output will be
                          different for each.
        -q, --queue-size: Defines the maximum length of the 
                          circular queue held in memory for
                          processing. By default, this is 100000
 -d, --max-time-distance: Defines the maximum difference in time
                          that two entries can have and still be
                          considered for correlation (t2 and t3).
-e, --max-pulse-distance: Defines the maximum difference in pulse
                          number that two entries can have and 
                          still be considered for correlation 
                          (t3 only).
             -g, --order: Order (g(n)(t1...tn-1)) of the 
             			  correlation to perform. By default this
             			  is 2, the standard cross-correlation of
             			  two channels.
          -c, --channels: Number of channels in the incoming
                          stream. By default, this is 2 
                          (Picoharp).
  -r, --channels-ordered: Organize the output such that the 
                          channels are in order. By default, 
                          this is not performed.
              -h, --help: Print this message.

       This program assumes the input stream is time-ordered.
\end{verbatim}

\subsubsection{Input}
T2 and T3 modes accept data of the form produced by \picoquant, as specified in section~\ref{sec:picoquant_output}.

\subsubsection{Output}
The exact output will depend on the mode and order of correlation, but it always adheres the following form:
\begin{verbatim}
channel 0, channel 1, time 1, ..., channel 2, ... \n
\end{verbatim}
where the times are either times or pulses, and follow the order (pulse, time). Also, the channels here are not necessarily ordered, because the exact order of the signals in the correlation can be of great importance. For example, for a \gn{2} of T2 data:
\begin{verbatim}
channel 0, channel 1, time 1-time 0 \n
\end{verbatim}
for \gn{3} of T2 data:
\begin{verbatim}
channel 0, channel 1, time 1-time 0, 
  channel 2, time 2-time 0 \n
\end{verbatim}
for \gn{3} of T3 data:
\begin{verbatim}
channel 0, channel 1, pulse 1-pulse 0, time 1-time 0,
   channel 2, pulse 2-pulse 0, time 2-time 0 \n
\end{verbatim}

By default, the ordering of the channels is that found in the stream. However, for some applications it is useful to order the channels and record both positive- and negative-time correlations on the same histogram. To account for this, pass the flag \texttt{--channels-ordered} to order the channels and apply the appropriate sign to the time differences.

By default, the program will correlate all entries in a stream. This can easily cause memory problems, so it is recommended that a maximum time distance is specified for T2 data, or a maximum pulse distance for T3 data. A maximum time distance may also be specified for T3 data, but in principle this is unnecessary. Note that all channels are treated equally by these limits. 

Currently, \correlate{} uses a fixed-length circular buffer to store entries, so if errors report that the buffer is too small try changing the length with \texttt{--queue-size}.

\subsection{Examples of usage}
Finding the correlation events for a \gn{2} of T2 data:
\begin{verbatim}
> picoquant --file-in data.ht2 --number 10000 | \
  correlate --channels 4 --mode t2 \
  --max-time-distance 1000
3,2,932
3,0,558
3,1,508
\end{verbatim}
the same, with channels ordered:
\begin{verbatim}
> picoquant --file-in data.ht2 --number 10000 | \
  correlate --channels 4 --mode t2 \
  --max-time-distance 1000 --channels-ordered
2,3,-932
0,3,-558
1,3,-508
\end{verbatim}
\gn{2} of T3 data:
\begin{verbatim}
> picoquant --file-in data.ht3 --number 100 | \
  correlate --channels 4 --mode t3 \
  --max-pulse-distance 1000
3,3,447,14436
1,1,115,-15636
3,2,369,-28240
1,1,986,66088
0,3,240,21380
\end{verbatim}
\gn{3} of T3 data:
\begin{verbatim}
> picoquant --file-in data.ht3 --number 1000 | \
  correlate --channels 4 --mode t3 --order 2 \
  --max-pulse-distance 1000
3,3,10,-44540,0,913,8648
3,0,155,9044,2,353,-792
2,3,128,47316,3,144,42004
2,2,44,-32120,3,300,1380
2,2,44,-32120,2,359,-4924
2,3,300,1380,2,359,-4924
2,3,256,33500,2,315,27196
1,3,460,72356,2,847,20448
3,2,387,-51908,3,603,-43404
2,1,78,-33380,2,323,-60748
1,3,54,-39056,2,239,-60648
3,2,139,39596,3,364,11248
2,2,27,-82228,3,999,-10108
\end{verbatim}

\subsection{Implementation details}
\label{sec:correlation_implementation}
The math and notation from section~\ref{sec:math_background} will feature heavily in this section, so you should become familiar with the results of that section before proceeding. 

The problem \correlate{} must address is that of generating efficiently the set of all correlation events, given a set of photons. That is, we must find all events of the form
\begin{equation}
\braces{(\photon_{0},\ldots\photon_{n-1})
        \left|
        \begin{aligned}
        \photon_{0}\in\photons_{c_{0}};\\
        \ldots; \\
        \abs{\braces{\photon_{0},\ldots\photon_{n-1}}}=n;\\
        \Time(\photon_{1})-\Time(\photon_{0})=\tau_{0};\\
        \ldots
        \end{aligned}
        \right.}
\end{equation}
In long form, we must find all tuples of $n$ unique photons which satisfy specific rules for their relative time delays. To do this, we will start with the information we can know or enforce for the incoming stream of photons \photons:
\begin{enumerate}
\item The set \photons{} of all photons is time-ordered ($\Time(\photon_{j})\le\Time(\photon_{k})$ for $j<k$).
\item The correlation will only be meaningful for a time window $\timewindow\subseteq\integrationtime$  much smaller in span than the full integration time.
\end{enumerate}
From this, we see that it should be possible to start from some photon in the stream, find all possible tuples including that photon, then remove it from consideration and move on. That is, for a given photon \photon, there will be some subset of possible times \timewindow{} in which correlation tuples can exist, and once we have exhausted all photons in that window we can ignore the original photon for all future correlations. 

Our task can thus be divided into three main procedures:
\begin{enumerate}
\item Generate each subset $\photons_{\timewindow}$.
\item Generate all unique tuples $\vec{\photon}$ of $n$ photons in a given $\photons_{\timewindow}$.
\item Calculate the relative time delays of the photons in $\vec{\photon}$.
\end{enumerate}
%This latter rule can be expressed as a modification of the conditions in the set:
%\begin{align}
%\photons_{\timewindow}\equiv\braces{\photon\left|\photon\in\photons;~\Time(\photon)\in\timewindow\right.}\\
%\braces{(\photon_{0},\ldots\photon_{n-1})
%        \left|
%        \begin{aligned}
%        \photon_{0}\in\photons_{c_{0}}\cap\photons_{\timewindow};\\
%        \ldots; \\
%        \Time(\photon_{1})-\Time(\photon_{0})=\tau_{0};\\
%        \ldots;
%        \end{aligned}
%        \right.}
%\end{align}
%The former rule simplifies the algorithm we will devise to perform this calculation.

\subsubsection{The set $\photons_{\timewindow}$ can be generated efficiently from a time-ordered \photons}
Given a photon to base correlations from, the particular $\timewindow$ representing the span of possible times can be defined as:
\begin{equation}
\timewindow = \left[ \Time(\photon), \Time(\photon) + \abs{\timewindow} \right)
\end{equation}
Because the photon stream is time-ordered, we can generate the set by the following algorithm:
\begin{lstlisting}
for index, src_photon in enumerate(photons):
    current_photons = list()
    for dst_photon in enumerate(photons[index:]):
        if dst_photon.time - src_photon.time \ 
            < max_distance:
            current_photons.append(dst_photon)
        else:
            break

    correlate(src_photon, current_photons)
\end{lstlisting}
For each photon the stream the algorithm must examine enough photons to reach the end of $\timewindow$, so each event costs an amount proportional to the average density of photons in the stream, or roughyl O($\abs{\timewindow}$). Each photon must be processed, so the whole algorithm costs O($\abs{\photons}\abs{\timewindow}$). In the limit that $\timewindow=\integrationtime$, the algorithm costs O($\abs{\photons}^2$); at worst, for each photon it is necessary to compare with all other photons in the stream.

%Without loss of generality, we define a window window of time $\timewindow$ such that, for some bounds $a,b\in\wholes$, $a<b$:
%\begin{equation}
%\timewindow = [a,b)
%\end{equation}
%If we allow $a\rightarrow0$ and $b\rightarrow\integrationtime$, we recover the full set of times for the experiment, but for practical matters we will focus on this window \timewindow.
%
%Given that \photons{} is time-ordered, we can always draw from it a photon \photon{} with minimal time, so from here we will treat \photons{} as a queue, a structure which holds an arbitrary number of elements in a well-defined order. This queue is time-ordered, although there is some ambiguity in how to order photons arriving on different channels at the same time. Ultimately, the ordering of such photons is not important, but we can define a second order parameter for the channel if needed.
%
%In principle we could enumerate all time windows \timewindow{} with some specified \abs{\timewindow} and find events in that window, but there are far more windows than photons (otherwise, we could have treated the signal as a vector, as in section~\ref{sec:sampling_intensity}). Therefore, it is much more efficient to choose each window as starting at some photon, and draw photons from the queue until the window limit is surpassed. Once we have drawn this sub-queue $\photons_{\timewindow}$ we can turn our attention to generation of photon tuples from that set.
%
%Up to the tuple generation, our algorithm is:
%\begin{enumerate}
%\item[0.] Set $\photons_{\timewindow}=\emptyset$, correlation order $n$.
%\item Draw the next element $\photon$ from $\photons$:
%  \begin{enumerate}
%  \item If $\photon$ exists, add it to the last position in $\photons_{\timewindow}$.
%  \item If no $\photon$ exists (the queue is empty):
%    \begin{enumerate}
%    \item If $\abs{\photons_{\timewindow}}\ge n$, generate tuples from $\photons_{\timewindow}$.
%    \item Halt.
%    \end{enumerate}
%  \end{enumerate}
%\item Call $\photon_{-1}$ the last photon in $\photons_{\timewindow}$ and $\photon_{0}$ the first.
%\item If $\Time(\photon_{-1})-\Time(\photon_{0})\ge\abs{\timewindow}$, go to 1.
%\item If $\abs{\photons_{\timewindow}}\ge n$, generate tuples from $\photons_{\timewindow}$.
%\item Remove the $\photon_{0}$ from $\photons_{\timewindow}$, then go to 1.
%\end{enumerate}
%From this algorithm it is evident that the cost of building the windows scales most directly with the number of photons (we never have to perform more than $\abs{\photons}$ iterations of this algorithm), giving O(\abs{\photons}) for this step. 

To see the implementation of this algorithm, the relevant files are \texttt{correlate.c}, \texttt{correlate\_t2.c}, and \texttt{correlate\_t3.c}. In particular, the functions \texttt{*queue*} are the most relevant, as these handle the population and depopulation of \photons{} and $\photons_{\timewindow}$.

\subsubsection{Generating correlation events (photon tuples) from $\photons_{\timewindow}$}
Given a subset of photons $\photons_{\timewindow}$ and an original tagged photon $\photon_{0}$, we must generate all tuples of $n$ unique photons from this pool. That is, we must generate all unique combinations of $n$ photons from the set $\braces{\photon_{0}}\cup\photons_{\timewindow}$, or equivalently all unique combinations of $n$ choices of  $\abs{\braces{\photon_{0}}\cup\photons_{\timewindow}}$ items. Combination generation algorithms are well-established, and the one used here works by incrementing the trailing digits as needed:
\begin{lstlisting}
combination = range(1, n)
limit = N

def next_combination(combination, limit):
    leading_digit = combination[0]
    
    for index in reversed(range(len(combination))):
        final_index = index
        combination[index] = (combination[index]+1) \
                             % limit
        if combination[index] != 0:
            # No overflow, so we have a valid new value.
            break
    
    if final_index == 0:
        combination[0] = leading_digit + 1
       
    for index in range(final_index, len(combination)):
        combination[index] = combination[index-1] + 1
    
    # If True, the combination is valid. 
    return(combination[-1] < limit) 
\end{lstlisting}
This is a bit obtuse, so we will work out an example. Say we have 4 photons to correlate to order 3. We only want unique photons, so the first combination will be $(0,1,2)$ where we have included the tagged photon for clarity. To get the next combination, we increment the final digit and obtain $(0,1,3)$. This is still valid (all indices are within the limit), so we use it. The next combination is a bit trickier, and we follow these steps to obtain it:
\begin{enumerate}
\item $(1,3+1 \pmod{4}) = (1, 0)$
\item $(1+1, 0) = (2, 0)$
\item We have incremented a value without causing an integer overflow (mod 4), so now we must repopulate the overflowed digits with the smallest possible value.
\item $(2, 2+1) = (2, 3)$
\item $3 < 4$, so this is a valid combination.
\end{enumerate}
This process is repeated up to $(0,2,3)$, at which point $(0,3,4)$ would be generated. As this is not valid, we receive \texttt{False} as output to indicate as such, and the generation stops.

The exact scaling of this algorithm could be worked out by noting the frequency of incrementing $1, 2, \ldots$ digits, but we know it must cost something less than $n$ increments per step. Thus, this generation algorithm will process any given set $\photons_{\timewindow}$ in better than O($n\abs{\photons_{\timewindow}}$) time.

%Given the algorithm to find all subqueues $\photons_{\timewindow}$, we turn our attention to finding the tuples $(\photon_{0},\ldots\photon_{n-1})$ in a given $\photons_{\timewindow}$. Formally, we want to generate the elements of the set
%\begin{equation}
%\braces{(\photon_{0},\ldots\photon_{n-1})\left|\photon_{0},\ldots\in\photons_{\timewindow}\right.}
%\end{equation}
%This is actually a quite familiar problem, if we ignore the photon structure and instead focus on producing the appropriate indices from the queue. Call $N\equiv\abs{\photons_{\timewindow}}$, and note that we are looking to produce all unique permutations of $n$ elements of $\integers_{N}$. These can be ordered to produce:
%\begin{align*}
%&(0, 0,\ldots 0, 0) \\
%&(0, 0, \ldots 0, 1) \\
%&\ldots \\ 
%&(0, 0, \ldots 0, N-1) \\
%&(0, 0, \ldots 1, 0) \\
%&\ldots 
%\end{align*}
%These can be enumerated as the numbers $0,1,\ldots N^{n}-1$ in base $N$, which can be seen by treating each element of the tuple as a coefficient in the base expansion of a number. For example, any number $N\in\wholes$ can be expressed as a sum over powers of 2:
%\begin{equation}
%N = \sum_{j=0}^{n}{c_{j}2^{j}}
%\end{equation}
%for some $n\in\wholes$. While this is true, it is also subject to some redundancy, because we have shown that the positive-time correlation is sufficient for reconstruction all negative times (see section~\ref{sec:correlation_function}), so we actually only need to compute this factor for all time-ordered tuples. Additionally, any tuple containing the same photon twice is not important, because there will never be any structure to a photon correlated with itself. Thus we need only include the tuples for which the indices are ordered and unique, the upper hypertriangle in index space.
%
%Additionally, because the window will move to eliminate the first photon, any correlation not involving this photon should not be handled now. Thus the index tuples of interest are:
%\begin{align*}
%&(0,1,\ldots,n-2, n-1)\\
%&(0,1,\ldots,n-2, n)\\
%&\ldots\\
%&(0,1,\ldots,n-2,N-1)\\
%&(0,1,\ldots,n-1,n)\\
%&\ldots\\
%&(0,N-n,\ldots N-1)
%\end{align*}
%
%To generate these combinations of indices, apply the following algorithm:
%\begin{enumerate}
%\item[0.] Define $x\leftarrow(0,1,\ldots n-1)$, and index the $j$th element of $x$ as $x_{j}$. 
%\item Yield $x$.
%\item Increment as many digits of $x$ as necessary:
%  \begin{enumerate}
%  \item Set $j\leftarrow n-1$.  
%  \item If $j\le 1$, halt this loop.
%  \item Increment $x_{j}$. 
%  \item If $x_{j}\ge N$, set $x_{j}\leftarrow 0$, decrement $j$, and go to 1(b) (overflow of this digit).
%  \item Otherwise, set $j\leftarrow 0$, decrement $j$, and go to 1(b) (no overflow, stop incrementing).
%  \end{enumerate}
%\item Refill the overflowed digits of $x$:
% \begin{enumerate}
% \item If $x_{1}=0$, we have incremented up to the first index. Set $x_{1}\leftarrow x_{1}'+1$.
% \item Set $j\leftarrow 1$.
% \item If $j\ge n$, halt this loop.
% \item If $x_{j}=0$, set $x_{j}\leftarrow x_{j-1}+1$ (increment the digit based on the previous non-overflowed digit).
% \item Increment $j$, and go to 3(c).
% \end{enumerate}
%\item If $x_{n-1}\ge N$, halt. This is not a valid tuple of indices, which means we have exhausted all of the valid tuples.
%\item Otherwise, go to 1.
%\end{enumerate}
%This algorithm is not perfect, as we must loop over all elements of the tuple in the refilling step. This is ultimately a minor cost and could be accounted for in the implementation, but for \correlate{} the algorithm was implemented as described.
%
%In long form, we start at the right end of the tuple, incrementing values while moving left until we find a value which does not overflow past $N$. Once we find this value, we stop incrementing, then form the next possible tuple from the leading non-zero index, or the previous value of the leading digit if we have overflowed that as well. If the tuple can be refilled without overflowing, it is valid and we yield it. Otherwise, we have reached the end and are finished.
%
%From the algorithm, we see that an increment costs, at worst, O($n$) loops. In reality the average is somewhat lower than this, and could be calculated exactly with some effort. Additionally, this algorithm will produce some number of tuples of somewhat less than order O($nN$). This behavior is sensible: a larger window ($N=\abs{\photons_{\timewindow}}$) gives more valid tuples of photons, and the higher order $n$ gives more iterations over that window.
%
To see the implementation of this algorithm in \correlate, examine the functions \texttt{*offsets*} in \texttt{combinations.c}.

\subsubsection{Production of the correlation event, given a photon tuple}
Given a tuple of $n$ photons, all correlation events corresponding to that tuple can be achieved by determining the displacements between all permutations of those photons. For example, two photons $\photon_{0}$ and $\photon_{1}$ will contribute both to $\gn{2}_{(0,1)}$ and $\gn{2}_{(1,0)}$, so we must consider the $\tau$ produced by treating each ordering of the two photons. Generation of permutations is an equivalent problem to generation of integers in some base, such that no two digits are identical. In the code, this is achieved by incrementing through all $n$-digit numbers in base $n$, and storing the ones with no identical digits in an array for later usage. This requires the generation of $n^{n}$ values and the storage of $n!$ values, but this should be a small number in most circumstances. 

To see how the permutations are generated, see \texttt{combinations.c}. To see how these are used, see \texttt{correlate\_t*.c}, particularly the \texttt{correlate\_t*\_block} procedures.
%There are two distinct modes enabled in \correlate{} for producing the correlation events: with and without ordering of channels. We will deal with the time-ordered, channel-unordered case first. 
%
%Given a tuple of photons $(\photon_{0},\ldots\photon_{n-1})$ known to satisfy the conditions for including in calculating \gn{n}, we must produce the time differences $(\tau_{1}, \ldots\tau_{n-1})$. This can be done with the following algorithm:
%\begin{enumerate}
%\item[0.] Set $j\leftarrow 1$.
%\item If $j\ge n$, halt and yield $(\tau_{1},\ldots\tau_{n-1})$.
%\item Set $\tau_{j}\leftarrow \Time(\photon_{j}) - \Time(\photon_{0})$.
%\item Increment $j$ and go to 1.
%\end{enumerate}
%This process scales as O($n$), although the constant factor is quite small relative to the other steps in the overall algorithm. Correlation for T3 mode involves a second term for the pulse difference, but it otherwise identical.
%
%To perform this same step for channel-ordered (time-unordered) photons, we can pre-populate a list of all possible channel orders and combinations and the order of the indices to choose, instead of incrementing from start to finish. The details of this will be described in section~\ref{sec:histogram}, but the result is that the cost of this operation is only upfront, and there is essentially no additional cost once the list of combinations exists.

%\subsubsection{Definition of the correlation as the order of a set}
%As mentioned in section~\ref{sec:correlate_math}, T3 and T2 data are closely related and can be treated similarly. To understand how this is possible, it is worth spending some time considering what information is required to compute the correlation.
%
%In equation~\ref{eq:g2}, the denominator is an average intensity of a signal. This can be computed simply by determining the duration of the signal and the number of counts over that interval, and can be handled by using the result of \intensity{} \texttt{--count-all}. Thus the real problem is the computation of the numerator, which is somewhat imposing at first glance:
%\begin{equation}
%\angles{I_{0}(t)\prod_{j=1}^{n-1}{I_{j}(t+\tau_{j})}}
%\end{equation}
%To simplify matters, we will start with the autocorrelation of a signal channel:
%\begin{equation}
%\angles{I(t)I(t+\tau)}
%\end{equation}
%In this situation, the signal can be thought of as being composed of some sum of delta functions with peak centers at the times photons arrived. Thus the contribution of any given pair of photons to the correlation at time $\tau$ is nonzero only if the difference of their arrival times is $\tau$. Thus, for a given value of $\tau$ and photon arrival times \braces{t}:
%\begin{equation}
%\gn{2}(\tau) \propto \left| \braces{(t_{j}, t_{k}) | t_{j},t_{k}\in\braces{t}; t_{j}-t_{k}=\tau} \right|
%\end{equation}
%This result can be extended to higher orders by enforcing the restriction that a tuple of time differences must be satisfied:
%\begin{equation}
%\begin{split}
%\gn{n}(\tau_{1}, &\ldots \tau_{n-1}) \propto \\
%   &\left| \braces{
%       (t_{0}, \ldots t_{n-1})
%       \left|\begin{split}
%       t_{0},\ldots t_{n-1}\in\braces{t}; \\
%       (t_{1}, \ldots t_{n-1}) - (t_{0}, \ldots t_{0}) = (\tau_{1}, \ldots \tau_{n-1})
%       \end{split}\right.
%%       \begin{gather*}
%%        \\
%%       
%%       \end{gather*}
%   } \right|
%\end{split}
%\end{equation}
%
%\subsubsection{Mapping T3 data onto T2-like data}
%Now that we have a general expression for calculation of \gn{n}, it is worthwhile to make an aside describing how to map T3 data onto T2-like data for correlation. Consider the basic form of a tuple of $n$ T3 records:
%\begin{equation}
%\left((c_{0}, p_{0}, t_{0}), \ldots (c_{n-1}, p_{n-1}, t_{n-1})\right)
%\end{equation}
%which can be mapped isomorphically onto:
%\begin{equation}
%\left((c_{0}, p_{0}), (c_{0}, t_{0}), \ldots (c_{n-1}, p_{n-1}), (c_{n-1}, t_{n-1})\right)
%\end{equation}
%which looks like a tuple for T2 records:
%\begin{equation}
%\left((c_{0}, t_{0}), \ldots (c_{n-1}, t_{n-1})\right)
%\end{equation}
%Ultimately, a T3 tuple of length $n$ can be mapped onto a corresponding tuple of length $2n$, such that any correlation \gn{n} of T3 data can be treated exactly as a corresponding correlation \gn{2n} of T2 data.
%
%\subsubsection{Correlation of the time-ordered stream}
%As with \intensity, \correlate{} expects a time-ordered stream (see section~\ref{sec:intensity_implementation}). 
%
%% For a correlation of order $n$, every unique combination of $n$ elements of the stream can contribute to \gn{n}, so the full correlation of stream of lengh $N$  costs O(N$^{n}$) to compute. This is reduced for a fixed window width to approximately O(Nw$^{n-1}$) for a window of width w, for reasons that will become clear shortly.




\section{Histogram}
\label{sec:histogram}

\subsection{Purpose}
This program performs a multi-dimensional histogram in time and pulse dimensions for T2 and T3 correlation events produced by \correlate. The output is a set of histogram bins and the number of events which fell into each. This output is \textit{not} normalized by bin width or any other factor, and represents the raw number of counts falling into each bin.

Additionally, \histogram{} can be used to build a histogram of T3 events as would be done in interactive mode. To do this, set the mode to T3, and order to 1.

For \gn{n>2}, all time dimensions are defined identically, and all pulse dimensions are defined identically.


\subsection{Command-line syntax}
\begin{verbatim}
Usage: histogram [-v] [-i file_in] [-o file_out] [-p print_every]
                 -d <left_time_limit, time_increment, 
                     right_time_limit> 
                 -e <left_pulse_limit, pulse_increment, 
                     right_pulse_limit> 
                 -c channels -g order -m mode

         -v, --verbose: Print debug-level information.
         -i, --file-in: Input file. By default, this is stdin
        -o, --file-out: Output file. By default, this is stdout.
            -m, --mode: Stream type. This is either t2 or t3, 
                        and the style of the output will be 
                        different for each.
     -d <time>, --time: The upper and lower bounds for the time
                        axis in the histogram, along with the 
                        number of bins to create. The required 
                        format is lower,bins,upper (no spaces).
   -e <pulse>, --pulse: Same as time, but for pulses. This is 
                        only relevant in t3 mode.
        -c, --channels: The number of channels in the incoming
                        stream. By default, this is 2 (Picoharp
                        or TimeHarp).
           -g, --order: The order of the correlation performed.
                        By default, this is 2 (the standard 
                        cross-correlation.
      -D, --time-scale: Sets whether the time scale is "linear", 
                        "log". or "log-zero" (includes zero-time
                        peak in the first bin. The default is a
                        linear scale.
     -E, --pulse-scale: Sets whether the pulse scale is "linear", 
                        "log", or "log-zero". The default is a 
                        linear scale.
            -h, --help: Print this message.

            This program assumes that the channels are presented
            in order.
\end{verbatim}

\subsubsection{Input}
The expected input is the ascii output of \correlate, except for an order 1 of T3 data. These parameters specify a histogramming of the individual timing events, to recover the histogram which would have been obtained in interactive mode.

As for the rest of the parameters, most of these follow the same pattern as \correlate and therefore will not be discussed here. The new flags involve definitions for the time and pulse dimensions: \texttt{--time}, \texttt{--time-scale}, \texttt{--pulse},  and \texttt{--pulse-scale}. The time and pulse dimensions behave identically, so we will only discuss the properties of one here.

For \texttt{--time}, the parameters specify the lower and upper bounds of the time axis, as well as the number of bins $n$ to create along that axis. For a linear spacing, the bin width $\Delta t$ is $(t_{\max}-t_{\min})/n$, such that the bins are defined by the ranges
\begin{equation}
\begin{aligned}
&[t_{\min},t_{\min}+\Delta t),\\
&[t_{\min}+\Delta t,t_{\min}+2\Delta t),\\
&\ldots\\
&[t_{\min}+(n-1)\Delta t,t_{\min}+n\Delta t)
\end{aligned}
\end{equation}
This linear spacing is the default behavior, but the flag \texttt{--time-scale} can produce two other scales: log, and log-zero. The log scale creates bins with fixed width over the span of $[\log(t_{\min}),\log(t_{\max}))$, as if often desired for measurements requiring long and short time correlations. The log-zero scale has identical behavior, except that any zero-time correlations ($\tau=0$) are placed into the first bin. Note that the log scale cannot handle zero-time correlations, and neither log not log-zero can handle negative-time correlations. These values will be dropped from the histogram, with an error message indicating this has happened.

\subsubsection{Output}
After the input stream terminates, \histogram{} outputs the bin definitions and the number of counts associated with that bin. Generically, this format is:
\begin{verbatim}
channel 0, channel 1, bin (1,1) lower, bin (1,1) upper, ...,
    channel 2, ... , 
    counts \n
\end{verbatim}
where the channels are integers, bin edges are floats, and the counts are integers. For every bin in the histogram, one line will be output. For T2 mode, the bin definition has only one dimension (time), so the format is:
\begin{verbatim}
channel 0, channel 1, time 1 lower, time 1 upper, 
           channel 2, time 2 lower, ...,
           counts \n
\end{verbatim}
T3 data have an additional dimension (pulse):
\begin{verbatim}
channel 0, channel 1, pulse 1 lower, pulse 1 upper,
                      time 1 lower, time 1 uppper,
           channel 2, ...
           counts \n
\end{verbatim}
See section~\ref{sec:histogram_examples} for specific examples of output in these formats.


\subsection{Examples of usage}
\label{sec:histogram_examples}
\subsubsection{Time-averaged photoluminescence lifetime from T3 data}
In T3 mode, a correlation order \gn{1} is code for interactive-like behavior. Formally this is a correlation of the laser pulse and the system response, but this language is not often used.
\begin{verbatim}
> picoquant --file-in data.pt3 |  \
  histogram --mode t3 --order 1 --channels 2 \
            --time 0,10,500000
0,0.00,50000.00,0
0,50000.00,100000.00,0
...
1,0.00,50000.00,11267838
1,50000.00,100000.00,14947845
1,100000.00,150000.00,1512803
1,150000.00,200000.00,1152498
1,200000.00,250000.00,1037717
1,250000.00,300000.00,973572
1,300000.00,350000.00,932802
1,350000.00,400000.00,899615
1,400000.00,450000.00,12278
1,450000.00,500000.00,0
\end{verbatim}
Note that \texttt{histogram} will operate on channel 0 as well, even though channel 1 is the only channel with any signal. This costs extra memory and some computational overhead at startup, but ultimately the cost is insignificant compared to the cost of processing the data stream.

\subsubsection{\gn{2} from T2 data}
This data represents an electronic sync source (channel 4) and the detection of the laser itself.
\begin{verbatim}
> picoquant --file-in data.ht2 | \
  correlate --mode t2 --order 2 \
            --channels 5 \
            --max-time-distance 1000 | \
  histogram --mode t2 --order 2 \
            --channels 5 \
            --time 0,10,1000
0,0,0.00,100.00,0
...
0,4,0.00,100.00,43
0,4,100.00,200.00,24
0,4,200.00,300.00,38
0,4,300.00,400.00,43
0,4,400.00,500.00,44
...
4,4,900.00,1000.00,0
\end{verbatim}

\subsubsection{\gn{2} from T3 data}
\begin{verbatim}
> picoquant --file-in data.pt3 | \
  correlate --mode t3 --channels 2 \
            --order 2 \
            --max-pulse-distance 3 \
  histogram --mode t3 --channels 2 \
            --order 2 --pulse 0,3,3 \
            --time -500000,2,500000
0,0,0.00,1.00,-500000.00,0.00,0
...
1,1,0.00,1.00,-500000.00,0.00,0
1,1,0.00,1.00,0.00,500000.00,104640
1,1,1.00,2.00,-500000.00,0.00,123289
1,1,1.00,2.00,0.00,500000.00,124676
1,1,2.00,3.00,-500000.00,0.00,231962
1,1,2.00,3.00,0.00,500000.00,231694
\end{verbatim}
As a rough benchmark, on a computer with a dual-core 3\giga\hertz{} processor running 32-bit Linux, this command required 25\second{} of wall time, for \texttt{data.ht3} containing 32.7 million photon records (18.1\kilo\cps) for a total of 0.8 million correlation events.

\subsubsection{\gn{3} from T2 data}
This T2 data is the same as the laser data from before:
\begin{verbatim}
> picoquant --file-in data.ht2 | \
  correlate --mode t2 --order 2 \
            --channels 5 \
            --max-time-distance 1000000 | \
  histogram --mode t2 --order 2 \
            --channels 5 \
            --time 0,1,1000000
0,0,0.00,1000000.00,0,0.00,1000000.00,31
0,0,0.00,1000000.00,1,0.00,1000000.00,55
0,0,0.00,1000000.00,2,0.00,1000000.00,57
...
4,0,0.00,1000000.00,2,0.00,1000000.00,2710
4,0,0.00,1000000.00,3,0.00,1000000.00,2235
4,0,0.00,1000000.00,4,0.00,1000000.00,0
...
\end{verbatim}
Note how much larger the time window must be to catch significant numbers of higher-order events.

\subsection{Implementation details}
The problem of populating and returning histograms for all possible correlations can be broken into a few distinct steps:
\begin{enumerate}
\item Construct a histogram for every permutation of channels.
\item For a given correlation event:
  \begin{enumerate}
  \item Identify the histogram corresponding to the permutation of channels.
  \item Identify the bin associated with the parameters of the correlation.
  \item Increment that bin in that histogram.
  \end{enumerate}
\item For every bin of every histogram, print the bin definition and associated counts
\end{enumerate}
As such, each of these will be discussed separately.

\subsubsection{The cross-correlations can be enumerated as a base-$\abs{\channels}$ numbers}
Each histogram corresponds to a single cross-correlation, as identified by the tuple $\vec{\channel}\in\channels^{n}$, for $\channels$ the set of all channels and correlation order $n$. As such, if we enumerate the channels as whole numbers ($0, 1, \ldots$), it is evident that each element of the tuple can be treated as the coefficient of an $n$-digit number in base $\abs{\channels}$. Mapping these tuples onto the set of whole numbers can thus be achieved by the following formula:
\begin{equation}
\Index(\vec{\channel}) = \sum_{j=0}^{n-1}{\channel_{j}\abs{\channels}^{n-1-j}}
\end{equation}
where the elements $\channel$ refer implicitly to the index of that channel in our enumeration.
If $\abs{\channels}=2$, this is identical to the expression of an $n$-digit binary number.

In the software, all possible cross-correlations are enumerated and the corresponding histograms allocated before beginning the calculation. This requires some computational overhead at instantiation, and if an application requires the calculation of large numbers of histograms it may be more efficient to modify the code to output and reset upon receiving particular signals.

The implementation of these methods can be found in \texttt{histogram\_gn.c} and \texttt{combinations.c}.

\subsubsection{A histogram is function of $n$-dimensional vectors mapping mapping onto integers}
Once the particular cross-correlation has been identified, the task falls to that of incrementing a counter corresponding to the appropriate histogram bin. The purpose of a histogram is to divide some phase space into well-defined smaller blocks, and then to count the number of events which fall into those blocks. We will restrict ourselves to rectangular volumes, so the task of identifying the correct volume of phase space can be reduced to determining the correct index along all axes, and thus each indexing step is identical to that for a single-dimensional histogram. 

In one dimension, we first define a range of values into which the events can fall, for example $\timewindow=\left[\timewindow\upminus,\timewindow\upplus\right)\subset\integers$. Next, we define some number $N$ of ranges $\resolution$ whose members collectively span $\timewindow$. These $\resolution$ can be enumerated $0,1,\ldots N-1$, so assign these indices in order to the sorted $\resolution$. Now this one dimension is represented by an $N$-dimensional vector whose dimensions represent some $\resolution$. The task then turns to mapping any value $z\in\integers$ to the appropriate $\resolution$.

For linearly-spaced sub-ranges, this identification can be achieved in O(1) time by:
\begin{equation}
\Index(x) = \timewindow\upminus + x\parens{\frac{\timewindow\upplus-\timewindow\upminus}{N}}
\end{equation}
However, in the code this is not used, and instead a more general binary search algorithm (costing O($\log(N)$)) is implemented to permit arbitrary spacings of these ranges. The binary algorithm determines the placement of an element into a sorted list by iterative division of the list into upper and lower halves, until the appropriate element is define. This is implemented as:
\begin{lstlisting}
def binary_search(value, bins):
    upper = len(bins)
    lower = 0
    
    if value < bins[0] or values > bins[-1]:
        # Not in the bounds
        return(False)
     
    while True:
        middle = (upper - lower)/2
        if value in bins[middle]:
            # Just right
            return(middle)
        elif value < bins[middle]:
            # Too high
            upper = middle
        else:
            # Too low
            lower = middle
\end{lstlisting}
Because this must be performed for each dimension of the correlation, the search costs O($n\log{(N)}$) time, compared to the O($n$) for the complete linear search. 

To see how this is implemented in \histogram, see \texttt{histogram\_gn.c} and \texttt{histogram\_t*.c}. 

\subsubsection{Printing the histogram}
Having exhausted the stream of correlation events, the final task is to print all of the histogram bins in a readable format. This is done by iterating over the histograms, then iterating over the bins, printing the counts associated with each bin. How this process is performed should be evident from the preceding discussion, and for the details refer to the routine \texttt{print\_gn\_histogram} in \texttt{histogram\_gn.c}.

Note that the output of $\histogram$ is not normalized in any way: only the number of counts is reported for each bin.

\section{GN}
\subsection{Purpose}
Given the $n$th-order histogram output from \histogram, \GN{} assembles the cross-correlations and produces all cross-correlations and the full autocorrelation. These results are normalized by intensity and bin width by default, but this behavior be suppressed with the flag \texttt{--no-bin-normalization}.

\subsection{Command-line syntax}

\subsection{Examples of usage}

\subsection{Implementation}
Most of the basic algorithms for this program have been laid out previously, so we will focus on the high-level tasks \GN{} must accomplish:
\begin{enumerate}
\item Parse the output from \histogram.
\item For the autocorrelation, sum all counts from each cross-correlation.
\item For normalization, apply average intensities and bin widths.
\item Return the final correlations.
\end{enumerate}

\section{Applications}
Now that we have laid the framework for the efficient handling of photon-arrival data, we can apply the results to interesting scientific problems.

\subsection{Fluorescence blinking}
In many fluorescent molecules, the emission is not steady at the single-molecule level, and it is useful to characterize this intermittency. One standard method for accomplishing this is to estimate the rate of photon arrival at fixed intervals in time, then determine the rate at which this rate fluctuates across some threshold. The procedure is as follows:
\begin{enumerate}
\item Define a series of fixed-width time bins for counting photons.
\item Determine how many photons arrive in each bin, and normalize the counts to determine an average rate of photon arrivals in that bin.
\item Given a threshold, map the count rate in each bin to 0 (below threshold) or 1 (above).
\item Determine the duration of each on (1) or off (0) period, and compute the histogram of these durations.
\end{enumerate}

For an example implementation. see \texttt{scripts/blinking.py}.

\subsection{Time-dependent photoluminescence lifetime}
The PL lifetime can be recovered from T3 data by calculating the order 1 histogram:
\begin{verbatim}
> picoquant --file-in data.pt3 | \
  histogram --mode t3 \
            --order 1 \
            --channels 2 \
            --time 0,10000,100000000
\end{verbatim}
In some situations it is desirable to calculate the PL lifetime for some interval of time and compare that with the lifetime at other intervals. This can be achieved by dividing the photon stream and histogramming the result accordingly. See \texttt{scripts/time\_dependent\_pl.py} for more details.

\subsection{Photon correlation spectroscopy}
By calculating the cross-correlation of two detection channels, we can study important properties of a signal, such as the number of fluorophores represented. This ultimately means we need to calculate \gn{2} for the signal, with the following steps:
\begin{enumerate}
\item Generate the stream of correlation events from the stream of photons.
\item Bin the events to form the cross-correlations.
\item Use the intensities at each channel to normalize the cross-correlation.
\end{enumerate}
See \GN{} for details of the implementation.

\subsubsection{Bunching and antibunching}
For t2 data, calculating \gn{2} with linear bin spacing should be sufficient. For t3 data, choosing a pulse bin width of 1 will enable direct comparison of the response to a single or neighboring pulses, as used in multi-exciton emission studies.

\subsubsection{Fluorescence correlation spectroscopy}
The correlator is reasonably fast and can handle the long time delays required for FCS measurements. One slight modification is that we will typically want a logarithmic time axis, which can be achieved by passing the flag \texttt{--time-scale log} to \GN{} or \histogram. Additionally, it is often useful to perform this measurement with the full autocorrelation, since the time delays are well beyond the dead time of the hardware, so use the full autocorrelation returned by \GN.


\appendixpage
\begin{appendix}
\section{Mathematical notation}
\label{sec:notation}
In this paper, there is extensive use of mathematical notation following some union of standards from various fields of mathematics. What follows is an attempt to define as much of this jargon as possible, such that a reader with a moderate background in the field could be reminded of its meaning.

%\newcommand{\braces}[1]{\ensuremath{\left\lbrace #1 \right\rbrace}}
%\newcommand{\angles}[1]{\ensuremath{\left\langle #1 \right\rangle}}
%\newcommand{\integers}{\ensuremath{\mathbb{Z}}}
%\newcommand{\wholes}{\ensuremath{\mathbb{N}}}
%\newcommand{\reals}{\ensuremath{\mathbb{R}}}
%\renewcommand{\vec}{\mathbf}
%\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}}

\subsection{Glossary}
\begin{itemize}
\item set: A collection of things. Typically indicated by \braces{\cdot}.
\item tuple: An ordered set of a finite number of elements, typically indicated by \parens{\cdot}. Similar in structure to a vector.
\end{itemize}

\subsection{Variables}
\begin{itemize}
\item $a$: Index of a bin in a histogram.
\item $b$: Time bin as specified by lower and upper bounds. When subscripted, this can indicate bin bounds or reference the bin by index (made clear by context).
\item $\channel$: Detection channel, typically represented by some whole number.
\item $\channels$: The set of all detection channels in an experiment.
\item $\Channel$: Function of a photon which returns the detection channel the photon arrived on.
\item $\delta$: A change in some variable.
\item $\resolution$: Time resolution of a detection channel.
\item $f$: Frequency.
\item $\gn{n}$: Correlation function of $n$th order.
\item $\photon$: Photon, a tuple consisting of a detection channel and some number of arrival time properties.
\item $\photons$: The set of all photons in an experiment. A subscript typically indicates some subset, such as photons on a detection channel or in some specified time window.
\item $\Index$: Function returning the index of a histogram, given the set of channels and a tuple of elements of that set.
%\item $\Histogram$: The histogram function, which accepts bin definitions and outputs the counts in those bins.
%\item $\iota$: A ``real'' physical signal being sampled in an experiment.
\item $I$: Signal, a real-valued function of time.
\item $n$: The order of a correlation.
%\item $N$: The number of elements in a set, the length of a stream or vector, or the number of detection channels.
\item $p$: Pulse number.
\item $\Pulse$: Function of a photon which returns the pulse the photon arrived after.
\item $\rho$: Pulse delay.
\item $t$: Time.
\item $\Time$: Function of a photon which returns the arrival time of the photon.
\item $\tau$:  Time delay.
\item $\timewindow$: Time window, some subset of time in the experiment.
\item $\integrationtime$: Integration time for the experiment.
%\item $\emptyset$: The empty set, or a lack of a value.
\end{itemize}

\subsection{Sets}
\begin{itemize}
\item $\cap$ ($\bigcap$): Intersection of two (some number of) sets.
\item $\cup$ ($\bigcup$): Union of two (some number of) sets.
\item $\in$: Inclusion, indication that an element is a member of a set.
\item $\abs{\cdot}$: Magnitude of a scalar or vector, or the number of elements in a set.
\item $\max,\min$: The maximum or minimum elements of a set, given some rule for sorting made clear explicitly or by context.
\item $\subset$: The set on the left is a proper subset of the set on the right: its members are elements of the right-hand set, but the two sets are not equal.
\item $\subseteq$: The set on the left is a subset of the set on the right: its members are elements of the right-hand set, and the two sets may be equal.
\end{itemize}

\subsubsection{Named sets}
There are a number of important sets which arise frequently in this paper:
\begin{itemize}
\item \reals: The set of all real numbers
\item \integers: The set of all integers (\braces{\ldots-1,0,1,\ldots}).
\item \wholes: The set of all positive integers, and zero (\braces{0,1,\ldots}).
\end{itemize}
Additionally, there are modifiers used to indicate special subsets:
\begin{itemize}
\item $\cdot^{*}$: As a superscript, this indicates that the set only contains non-negative numbers. For example, $\reals^{*}$ contains all elements $x$ such that $\abs{x}=x$.
\item $\cdot^{+}$: As a superscript, this indicates that the set only contains positive numbers. 
\item $\cdot_{n}$: As a subscript, this indicates a cyclic group of order $n$. For example, $\integers_{n}=\braces{0,1,\ldots,n-1}=\integers/n$. 
\end{itemize}

\subsubsection{Set builder notation}
Frequently, this paper contains expressions in the following form:
\begin{equation}
\photons_{\channel}=\braces{\photon\left|\photon\in\photons;~\Channel(\photon)=\channel\right.}
\end{equation}
To read this notation, start left of the pipe to see what elements of the set look like. In this case, all elements are photons (\photon). To the right side of the pipe are the properties these elements must have, that the photon exists in the set \photons{} of photons, and that its arrival channel is $c$. 

Other examples of this notation include:
\begin{align}
\reals^{*} &= \setbuilder{x}
                        {x\in\reals; \abs{x}=x} \\
\rationals &= \setbuilder{(p,q)}
                        {p\in\integers;~q\in\integers^{+}} \\
A\times B &= \setbuilder{(a,b)}
                       {a\in A;~b\in B}                       
\end{align}

\subsubsection{Ranges}
Square brackets and parentheses are used to indicate some continuous subset of values of a set. For example, the real numbers between 0 and 1, including 0 and 1, are denoted
\begin{equation}
\brackets{0,1} = \setbuilder{x}{x\in\reals;~x\ge 0;~x\le 1}
\end{equation}
To indicate that one of the endpoints is not included in the set, a parenthesis is used:
\begin{equation}
\left[0,1\right) = \setbuilder{x}{x\in\reals;~x\ge 0;~x<1}
\end{equation}
The source set is typically made clear by context.

\subsection{Other functions and relations}
\begin{itemize}
\item \angles{\cdot}: Average of the bracketed quantity over some variable or number of variables.
\item $\times$: Cartesian product of two sets.
\item $\sum$: Sum of some number of quantities.
\item $\prod$: Product of some number of quantities.
\item $\leftarrow,\rightarrow$: Assignment of some value to a variable, or association in a function.
\item $\ceil{\cdot}$: The smallest integer at least as large as the indicated quantity.
\item $\abs{\cdot}$: Magnitude of a scalar or vector, or the number of elements in a set.
\item $\equiv$: Indicates two quantities are equivalent. Typically used to denote a change in notation.
\item $\propto$: Indicates proportionality; the two sides of the relation are equal upon multiplication of one side by some scalar factor, which could be unity.
\end{itemize}

\end{appendix}

\end{document}
