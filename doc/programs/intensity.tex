
\chapter{Intensity}
\section{Purpose}
For T2 and T3 data, it is often useful to group records into fixed time bins and count the number of records in each bin. This program does just that, reporting the intensity at each channel for all data in a time-ordered stream. 

\section{Command-line syntax}
\begin{verbatim}
Usage: intensity [-v] [-i file_in] [-o file_out] [-c channels]
                 -w bin_width -m mode

           -v, --verbose: Print debug-level information.
           -i, --file-in: Input file. By default, this is
                          STDIN.
          -o, --file-out: Output file. By default, this is
                          STDOUT.
         -w, --bin-width: Width of the bin, in time or pulses
                          depending on the mode.
              -m, --mode: Stream type. This is either t2 or t3,
                          and the style of the output will be
                          different for each.
          -c, --channels: Number of channels in the stream. By
                          default, this is 2.
         -a, --count-all: Rather than counting records in 
                          distinct time bins, count all records 
                          in the stream.
              -h, --help: Print this message.

       This program assumes the input stream is time-ordered.
       
       If counting all events or printing the last one, the time
       written will be the time of the last event seen.
\end{verbatim}

\subsection{Input}
T2 and T3 modes accept data of the form produced by \program{picoquant}, as specified in section~\ref{sec:picoquant_output}.

\subsection{Output}
The output for both T2 and T3 modes is of the form:
\begin{verbatim}
lower time limit, upper time limit, 
  channel 0 intensity, channel 1 intensity, ... \n
\end{verbatim}
For T2 mode, the time bin is defined as a number of picoseconds. For T3 mode, the time bin is a number of pulses.

Passing the flag \texttt{--count-all} will ignore the time bins, and instead count all events on each channel as belonging to one large channel. 

\section{Examples of usage}
Count into 10\milli\second{} bins.
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 
0,10000000000,555,0
10000000000,20000000000,524,0
20000000000,30000000000,564,0
30000000000,40000000000,536,0
40000000000,50000000000,495,0
50000000000,60000000000,530,0
60000000000,70000000000,514,0
70000000000,80000000000,548,0
80000000000,90000000000,558,0
90000000000,100000000000,565,0
100000000000,110000000000,550,0
110000000000,120000000000,490,0
120000000000,130000000000,559,0
130000000000,140000000000,504,0
140000000000,150000000000,547,0
150000000000,160000000000,537,0
160000000000,170000000000,535,0
170000000000,180000000000,545,0
180000000000,186537236212,344,0
\end{verbatim}
Count all events:
\begin{verbatim}
> picoquant --file-in data.pt2 --number 100000 |  \
  intensity --bin-width 10000000000 --mode t2 --channels 2 \
  --count-all
0,186537236212,10000,0
\end{verbatim}

\section{Implementation details}
\label{sec:intensity_implementation}
Each channel can be treated independently, so we can focus on how to handle a single stream of records. 

Given a set of photons $\photon\in\photons$, our goal is to determine the number of $\photon$ whose arrival times are in a time range $\epsilon$:
\begin{equation}
I(\resolution) = \abs{\setbuilder{\photon}{\photon\in\photons;~\Time(\photon)\in\epsilon}}
\end{equation}
In our case, we will only be concerned with time intervals $\resolution$ which are consecutive and collectively span the full integration time:
\begin{align}
\resolution_{j} &= \left[[\resolution_{j}\upminus,\resolution_{j+1}\upplus\right) \\
\integrationtime &= \bigcup\limits_{j=0}^{m}{\resolution_{j}}
\end{align}
As such, any photon can belong to exactly one subset $\photons_{\resolution_{j}}$, and these $\resolution_{j}$ can each be visited exactly once by iterating through times in the experiment. This can be performed efficiently if we impose the condition that the stream of photons be time-ordered, by iterating over photons and bins alternately:
\lstset{language=Python}
\begin{lstlisting}
photon = next(photons)
time_bin = next(time_bins)
intensity = 0

while photon and time_bin:
    if photon in time_bin:
        intensity += 1
        photon = next(photon)
    else:
        yield(time_bin, intensity)
        time_bin = next(time_bins)
        intensity = 0

yield(time_bin, intensity)
\end{lstlisting}
As can be seen, this algorithm scales linearly with the number of time bins and photons, i.e. it scales as O(\abs{\photons}). This algorithm requires time-ordered photons and bins which never lag behind the photon stream, which are guaranteed by appropriate initialization of the photon and bin streams.

